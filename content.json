{"pages":[{"title":"","text":"关于作者 重庆土著，现居苏州，2020 年毕业于重庆理工大学计算机科学与技术专业，目前中国科学技术大学软件工程研究生在读 预备役程序员，喜欢捣鼓各种和计算机相关的酷玩意儿 狂热足球爱好者，主队重庆当代、阿森纳、荷兰，兹拉坦迷弟，所以也会看 AC 米兰的比赛 技能树 Java- 熟悉 SpringBoot、SpringCloud，了解 Redis 缓存相关、MyBatis、JBA 数据库相关， 学过一点 Android（做过一些简单的 APP），近期准备从 Java 基础知识开始梳理一下，同时学习一下 JVM 和 MQ 消息队列相关 前端 - 熟悉前端三剑客，常用 Vue.js，了解 React.js、Webpack 相关，用过 Sass、Echarts.js Python- 了解爬虫相关，用过 Flask 框架搭建后台，了解机器学习相关，使用过 numpy、pandas、sklearn 等，本科毕业设计用 Opencv+Keras 做过 CNN 手势识别交互系统 其他 - 熟悉 Git 操作，了解 Linux 命令，用过 Docker，了解过 SQL 优化 语言 - 英语六级（584 分），明年找到实习后准备考雅思，学过一点德语 项目 TODO 获奖 TODO","link":"/about/index.html"}],"posts":[{"title":"SPFA-BFS 的一种扩展","text":"一句话总结本篇题解内容:BFS 中每个点只入列一次，但有时，我们可能需要 BFS 中允许一个点入列多次才能解决问题，这种方法就是 SPFA。 简介SPFA 这种算法，如果你百度的话，你会发现大多是说他用于求最短路的，事实上，更宽泛的来理解，所有“可能要后悔”的 BFS，都可以用类似 SPFA 的思路来解决。 先说说经典的最短路问题，希望大家能借此理解为何说 SPFA 是可以“后悔”的。 经典问题 考虑这样一张图，1 号点是起点，边上的数字代表这条边的长度，你想求出 1 到 10 号点的最短路。 下面，说说为何朴素的 BFS 不行。 按照 BFS 的流程，初始 1 号点入列，然后 1 号点周围的 2 号和 3 号入列。此时，2 距 1 最短路更新为 4,3 距 1 最短路更新为 1。 于是，问题来了，我们看到，实际上 1 到 2 的最短路是1-&gt;3-&gt;4-&gt;2，其长度为 3。 但按照朴素的 BFS 来做，由于已经有 vis[2]=1 了，所以由 4 号点访问周围点时，2 号点就不会再入列了，这样，我们就会求出错误的最短路。 那怎么办呢？一个很显然的办法，就是——那我就再把 2 入列呗！ SPFA 算法 所以，SPFA 其实就是很简单的一件事儿：检测到某点距离变化，就把某点入列。 并且如前所述，这样的 SPFA 其实就不需要 vis 数组了，因为只要距离更新，点就要入列。 但下面代码中还是有 vis 数组，其实他的含义是：某个点当前正在队列里，vis值为 1，当前点不在队列里，vis值为 0。 需要注意，虽然名字都叫 vis，但这里的vis 数组和朴素 BFS 中的 vis 数组很不一样。 这里 vis 数组只是避免同一个点已经在队列里的情况下被加入队列多次而用的（再次强调，SPFA 是允许一个点多次入列的，只不过正在队列里的，确实没必要再入列了）。 那么具体看这道题，dis[i][j]表示到达第 i 行第 j 列的点所需要的最小花费，直接的状态转移看上去并不好想。 怎么办？ 不好想就不想了呗！ 只要某个点 dis 变得更小了，我们按照 SPFA 的思想，就二话不说给他入列，让他再更新周围点的dis，这样总是对的了吧。 所以说白了，SPFA，听上去高大上，其实是贼暴力的一种方法，只要检测到某点 dis 值改变，就在重新由这点开始 BFS，仅此而已。 代码 下面是代码： 1234567891011121314151617181920212223242526272829303132333435363738#define INF 10005int dis[105][105];bool inQue[105][105];int dx[]={0,0,0,1,-1};int dy[]={0,1,-1,0,0};class Solution {public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n=grid.size();int m=grid[0].size(); memset(dis,INF,sizeof(dis)); memset(inQue,false,sizeof(inQue)); queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(0,0)); inQue[0][0]=true; dis[0][0]=0; while(!q.empty()){ auto now=q.front();q.pop(); int x=now.first;int y=now.second; inQue[x][y]=false; for(int k=1;k&lt;5;k++){ if(x+dx[k]&lt;0||x+dx[k]&gt;=n||y+dy[k]&lt;0||y+dy[k]&gt;=m)continue; int val= k==grid[x][y]?dis[x][y]:dis[x][y]+1; if(dis[x+dx[k]][y+dy[k]]&gt;val){ dis[x+dx[k]][y+dy[k]]=val; if(!inQue[x+dx[k]][y+dy[k]]){ q.push(make_pair(x+dx[k],y+dy[k])); inQue[x+dx[k]][y+dy[k]]=true; } } } } return dis[n-1][m-1]; }}; &nbsp;&nbsp; 王希孟千里江山图卷","link":"/SPFA-BFS%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A9%E5%B1%95/"},{"title":"ST 表","text":"ST 表原理和模板代码 ST 表的目标 -RMQ 问题 简而言之，就是询问区间最值的问题 区间最值不具有区间可减性，不能用树状数组这样的数据结构来维护 ST 算法是 RMQ 问题的一个常用解法，使用了动态规划的思想。 预处理数组 f[x][i] 表示区间 $[x,x+2^i)$ 的最值，其中$$f[x][i]=min/max(f[x][i-1],f[x+2^{i-1}][i-1])$$ 对于询问区间[l,r], 设 $d=log_2(r-l+1)$，答案即为 $min/max(f[l][d],f[r-2^d+1][d])$ 代码1234567891011121314151617181920212223const int maxn=1e5+50;int n,m;int f[maxn][18];int que(int l,int r){ int d=log2(r-l+1); return max(f[l][d],f[r-(1&lt;&lt;d)+1][d]);}int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++) cin&gt;&gt;f[i][0]; for(int j=1;j&lt;=17;j++){ for(int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++){ f[i][j]=max(f[i][j-1],f[i+(1&lt;&lt;(j-1))][j-1]); } } for(int i=1,l,r;i&lt;=m;i++){ cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;que(l,r)&lt;&lt;'\\n'; }}","link":"/ST%E8%A1%A8/"},{"title":"git 常用命令","text":"git 常用命令的记录 拷贝项目：（Shift + insert）快速粘贴git clone https://github.com/bigbigtime/web.git 查看分支：（分支中显示绿色，为当前所处分支）git branch –listgit branch -a 切分支：git checkout 其他 当提示时，以下命令时，一模一样样输入即可，只需把 username、email 修改为你自己的注册的帐号即可。git config –global user.name “username”git config –global user.email “email”","link":"/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"前端样式知识整理","text":"块级元素居中 块级元素：就是占据页面整行的，如 div/ul/li/p/section/header/footer 等 12345选择器 { width: 1200px; // 一定要设置宽度 margin: 0 auto; // 居中 text-align: center; // 文字居中} 内联元素居中 内联元素：不占据页面整行，可以拼接在一起，如 span/a/em/i/b 等 123选择器 { text-align: center; // 居中} float、clearfix 浮动常见 bug最常见的 bug，浮动问题：float: left、float: right 造成严重的问题：当 “子级” 元素使用 float 时，无法撑开 “父级” 元素高度，后续的布局越来越乱。 解决方式：当 “子级” 元素使用 float 时，父级一定要清除浮动（clearfix）。 常见三种： 添加新的元素 、应用 clear：both；不好之外：额外增加了一个无意义的标签，有点占用资源。 父级上增加属性 overflow：hidden；不好之外就在于超出的元素会被隐藏，看不见 定义一个伪类的 css 样式，把 clearfix 添加到父元素。 注：当子级使用了 float 时，父级务必清浮动 1234567891011.clearfix:after{content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;}.clearfix{ display: inline-block; }* html .clearfix{ height: 1%; }.clearfix { display: block; } 图片无法完全撑开时 修改图片的 display 值为 block 123img{ display: block;} 内联元素使用 float 浮动后自动转换为块级元素123span{ float: left; //span 自动转换为块级元素} 奇异盒模型div 长宽固定，忽略 border 和 padding 导致的 div 变大 Padding 的值会累加到元素本身 如：元素本身的值 为 100px，设置 padding-left: 50px；那么：元素本身的值就变为了 150px 1-webkit-box-sizing: border-box; sass 封装方法的定义与使用 定义 1234567@mixin webkit($type,$value){ -webkit-#{$type}: $value; -moz-#{$type}: $value; -ms-#{$type}: $value; -o-#{$type}: $value; #{$type}: $value;} 使用 1@include webkit(box-sizing,border-box) Position 定位、脱离文档 绝对定位：position: absolute;相对定位：position: relative; 记住一个重要的概念：绝对定位元素，居于“相对定位” 或 “绝对定位”的元素进行定位 简单的理解就是：绝对定位元素，需要一个参考对象（父级元素），参考对象的属性是 “相对定位” 或 “绝对定位” 通过设置 top、right 、bottom 、left 进行定位，常使用的值为 px、% 绝对定位元素水平、垂直居中 设置 50% 后需要拉回元素宽高的一半 123456789选择器 { position:absolute; top:50%; left:50%; width:50px; width:50px; margin-top:-25px; margin-left:-25px;}","link":"/%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"title":"最小生成树代码存档 -prim 和 kruskal","text":"最小生成树代码存档，基于《算法笔记》中的代码，方便以后查看使用。 prim 算法 伪代码 12345678910111213//G 为图，一般设成全局变量，数组 d 为顶点与集合 s 的最短距离Prim(G,d[]){ 初始化; for(循环 n 次){ u= 使 d[u] 最小的未被访问的顶点的标号; 记 u 已被访问; for(从 u 出发能够到达的所有顶点 v){ if(v 未被访问 &amp;&amp; 以 u 为中介点使得 v 与集合 s 的最短距离 d[v]更优){ 将 G[u][v]赋值给 v 与集合 s 的最短距离 d[v]; } } }} 邻接数组代码 123456789101112131415161718192021222324252627282930int n,G[MAXN][MAXN]; //n 为顶点数，MAXN 为最大顶点数int d[MAXN]; // 顶点与集合 s 的最短距离bool vis[MAXN]={false}; // 标记数组，vis[i]==true 表示已访问。初值为 falseint prim(){ // 默认 0 号为初始点，函数返回最小生成树的边权之和 fill(d,d+MAXN,INF); //fill 函数将整个 d 数组赋为 INF（慎用 memset） d[0]=0; // 只有 0 号顶点到集合 s 的距离为 0，其余全为 INF int ans=0 // 存放最小生成树的边权之和 for(int i=0;i&lt;n;i++){ // 循环 n 次 int u=-1,MIN=INF; //u 使 d[u] 最小,MIN 存放该最小的 d[u] for(int j=0;j&lt;n;j++){ // 找到未访问的顶点中 d[]最小的 if(vis[j]==false &amp;&amp; d[j]&lt;MIN){ u=j; MIN=d[j]; } } // 找不到小于 INF 的 d[u]，则剩下的顶点和集合 s 不连通 if(u==-1) return -1; vis[u]=true; // 标记 u 为已访问 ans+=d[u]; // 将与集合 s 距离最小的边加入生成树 for(int v=0;v&lt;n;v++){ //v 未访问 &amp;&amp; u 能到达 v &amp;&amp; 以 u 为中介点可以使 v 离集合 s 更近 if(vis[v]==false &amp;&amp; G[u][v] != INF &amp;&amp; G[u][v]&lt;d[v]){ d[v]=G[u][v]; // 将 G[u][v] 赋值给 d[v] } } } return ans;} 邻接表代码 12345678910111213141516171819202122232425262728293031323334353637struct Node{ int v,dis; //v 为边的目标顶点，dis 为边权};vector&lt;Node&gt; Adj[MAXN]; // 图 G，Adj[u] 存放从顶点 u 出发的可以到达的所有顶点 int n; //n 为顶点数，图 G 使用邻接表实现，MAXN 为最大顶点数int d[MAXN]; // 顶点与集合 s 的最短距离bool vis[MAXN]={false}; // 标记数组，vis[i]==true 表示已访问。初值为 falseint prim(){ // 默认 0 号为初始点，函数返回最小生成树的边权之和 fill(d,d+MAXN,INF); //fill 函数将整个 d 数组赋为 INF（慎用 memset） d[0]=0; // 只有 0 号顶点到集合 s 的距离为 0，其余全为 INF int ans=0 // 存放最小生成树的边权之和 for(int i=0;i&lt;n;i++){ // 循环 n 次 int u=-1,MIN=INF; //u 使 d[u] 最小,MIN 存放该最小的 d[u] for(int j=0;j&lt;n;j++){ // 找到未访问的顶点中 d[]最小的 if(vis[j]==false &amp;&amp; d[j]&lt;MIN){ u=j; MIN=d[j]; } } // 找不到小于 INF 的 d[u]，则剩下的顶点和集合 s 不连通 if(u==-1) return -1; vis[u]=true; // 标记 u 为已访问 ans+=d[u]; // 将与集合 s 距离最小的边加入生成树 // 只有下面这个 for 与邻接矩阵写法不同 for(int j=0;j&lt;Adj[u].size();j++){ int v=Adj[u][j].v; if(vis[v]==false &amp;&amp; Adj[u][j].dis&lt;d[v]){ // 如果 vw 未访问 &amp;&amp; 以 u 为中介点可以使 v 离集合 s 更近 d[v]=G[u][v]; // 将 G[u][v] 赋值给 d[v] } } } return ans;} kruskal 算法 伪代码 12345678910111213int kruskal(){ 令最小生成树的边权之和为 ans、最小生成树的当前边数 Num_Edge; 将所有边按边权从小到大排序; for(从小到大枚举所有边){ if(当前测试边的两个端点在不同的连通块中){ 将该测试边加入最小生成树中; ans += 测试边的边权; 最小生成树的当前边数 Num_Edge 加1; 当边数 Num_Edge 等于顶点数减1 时循环结束; } } return ans;} 代码12345678910111213141516171819202122232425262728293031323334353637383940// 边集定义部分struct edge{ int u,v; // 边的两个端点编号 int cost; // 边权}E[MAXE]; // 最多有 MAXE 条边bool cmp(edge a,edge b){ return a.cost&lt;b.cost;}// 并查集部分int father[MAXN];int findFather(int x){ if(x!=father[x]) return father[x]=findFather(father[x]); return x;}//kruskal 部分，返回最小生成树的边权之和，参数 n 为顶点个数，m 为图的边数int kruskal(){ int ans=0,Num_Edge=0; for(int i=0;i&lt;n;i++){ father[i]=i; } sort(E,E+m,cmp); for(int i=0;i&lt;m;i++){ int faU=findFather(E[i].u); int faV=findFather(E[i].v); if(faU!=faV){ father[faU]=faV; ans+=E[i].cost; Num_Edge++; if(Num_Edge==n-1)break; } } if(Num_Edge!=n-1) return -1; return ans;} 简化版代码（based on leetcode1584）1234567891011121314151617181920212223242526272829303132333435363738394041424344const int MAXN = 1000 + 50;int fa[MAXN];int getFather(int x){ if (fa[x] == x) return x; return fa[x] = getFather(fa[x]);}bool mergeFather(int x, int y){ int fx = getFather(x), fy = getFather(y); if (fx == fy) return false; if (fx &gt; fy) swap(fx, fy); fa[fx]= fy; return true;}struct Edge{ int x, y, w; Edge(){} Edge(int x0, int y0, int w0){ x = x0; y = y0; w = w0; }}edge[MAXN * MAXN];bool cmp(const Edge &amp;a, const Edge &amp;b){ return a.w &lt; b.w; }class Solution {public: int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { int n = points.size(), m = 0; for (int i = 0; i &lt; n; i++) for (int j = i + 1; j &lt; n; j++) edge[m++] = Edge(i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])); sort(edge, edge + m, cmp); for (int i = 0; i &lt; n; i++) fa[i] = i; int ans = 0, cnt = n; for (int i = 0; i &lt; m &amp;&amp; cnt &gt; 1; i++){ int x = edge[i].x, y = edge[i].y, w = edge[i].w; if (mergeFather(x, y)){ ans += w; --cnt; } } return ans; }};","link":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%BB%A3%E7%A0%81%E5%AD%98%E6%A1%A3-prim%E5%92%8Ckruskal/"},{"title":"树状数组","text":"树状数组原理和模板代码 树状数组的目标 - 动态前缀和问题 求数列 [1,r] 元素的和，即 $\\sum^{r}_{i=1}{a_i}$ 的值 修改 ${a_x}$ 的值为 v lowbit 操作lowbit(x)=-x&amp;x 树状数组定义 令第 i 个位置记录（i-lowbit(i),i]中的数字的和 令第 i 个位置的父节点为 i+lowbit(i) 性质： 一个节点 i，记录区间（i-lowbit(i),i]的信息，其子节点记录的区间不会相互覆盖，且按照由小到大依次覆盖区间(i-lowbit(i),i) 一个位置 i，仅会被节点 i 及其祖先节点覆盖 代码 更新操作 123void update(int x,int y){ while(x&lt;=n) d[x]+=y,x+=lowbit(x);} 查询操作 12345int ask(int r){ int res=0; while(r) res+=d[r],r-=lowbit(r); return res;} 树状数组经典应用 - 求逆序对个数 遍历数组，遍历过程中 ans+=ask(MAX)-ask(a[i]) 同时更新update(a[i],1) 123456789输入数组到 a[n]，如 [5,4,2,6,3,1]for(int i=0;i&lt;=n;i++){ res+=ask(MAX)-ask(a[i]); update(da[i],1);} 输出答案 res","link":"/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"title":"离散化","text":"离散化代码 1234567891011121314int da[MAXN],cc[MAXN];int n,m;cin&gt;&gt;n,m=n;for(int i=1;i&lt;=n;i++){ cin&gt;&gt;da[i],cc[i]=da[i];}// 离散化 sort(cc+1,cc+1+n);m=unique(cc+1,cc+1+n)-(cc+1);for(int i=1;i&lt;=n;i++){ da[i]=lower_bound(cc+1,cc+1+m,da[i])-cc;}// 离散化","link":"/%E7%A6%BB%E6%95%A3%E5%8C%96/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"ST表","slug":"ST表","link":"/tags/ST%E8%A1%A8/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"样式","slug":"样式","link":"/tags/%E6%A0%B7%E5%BC%8F/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"prim","slug":"prim","link":"/tags/prim/"},{"name":"kruskal","slug":"kruskal","link":"/tags/kruskal/"},{"name":"树状数组","slug":"树状数组","link":"/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"离散化","slug":"离散化","link":"/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"代码归档","slug":"算法/代码归档","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E5%BD%92%E6%A1%A3/"}]}