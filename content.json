{"pages":[{"title":"","text":"关于作者 重庆土著，现居苏州，2020 年毕业于重庆理工大学计算机科学与技术专业，目前中国科学技术大学软件工程研究生在读 预备役程序员，喜欢捣鼓各种和计算机相关的酷玩意儿 狂热足球爱好者，主队重庆当代、阿森纳、荷兰，兹拉坦迷弟，所以也会看 AC 米兰的比赛 技能树 Java- 熟悉 SpringBoot、SpringCloud，了解 Redis 缓存相关、MyBatis、JBA 数据库相关， 学过一点 Android（做过一些简单的 APP），近期准备从 Java 基础知识开始梳理一下，同时学习一下 JVM 和 MQ 消息队列相关 前端- 熟悉前端三剑客，常用 Vue.js，了解 React.js、Webpack 相关，用过 Sass、Echarts.js Python- 了解爬虫相关，用过 Flask 框架搭建后台，了解机器学习相关，使用过 numpy、pandas、sklearn 等，本科毕业设计用 Opencv+Keras 做过 CNN 手势识别交互系统 其他- 熟悉 Git 操作，了解 Linux 命令，用过 Docker，了解过 SQL 优化 语言- 英语六级（584 分），明年找到实习后准备考雅思，学过一点德语 项目 TODO 获奖 TODO","link":"/about/index.html"}],"posts":[{"title":"SPFA-BFS 的一种扩展","text":"一句话总结本篇题解内容:BFS 中每个点只入列一次，但有时，我们可能需要 BFS 中允许一个点入列多次才能解决问题，这种方法就是 SPFA。 简介SPFA 这种算法，如果你百度的话，你会发现大多是说他用于求最短路的，事实上，更宽泛的来理解，所有“可能要后悔”的 BFS，都可以用类似 SPFA 的思路来解决。 先说说经典的最短路问题，希望大家能借此理解为何说 SPFA 是可以“后悔”的。 经典问题 考虑这样一张图，1 号点是起点，边上的数字代表这条边的长度，你想求出 1 到 10 号点的最短路。 下面，说说为何朴素的 BFS 不行。 按照 BFS 的流程，初始 1 号点入列，然后 1 号点周围的 2 号和 3 号入列。此时，2 距 1 最短路更新为 4,3 距 1 最短路更新为 1。 于是，问题来了，我们看到，实际上 1 到 2 的最短路是1-&gt;3-&gt;4-&gt;2，其长度为 3。 但按照朴素的 BFS 来做，由于已经有 vis[2]=1 了，所以由 4 号点访问周围点时，2 号点就不会再入列了，这样，我们就会求出错误的最短路。 那怎么办呢？一个很显然的办法，就是——那我就再把 2 入列呗！ SPFA 算法 所以，SPFA 其实就是很简单的一件事儿：检测到某点距离变化，就把某点入列。 并且如前所述，这样的 SPFA 其实就不需要 vis 数组了，因为只要距离更新，点就要入列。 但下面代码中还是有 vis 数组，其实他的含义是：某个点当前正在队列里，vis值为 1，当前点不在队列里，vis值为 0。 需要注意，虽然名字都叫 vis，但这里的vis 数组和朴素 BFS 中的 vis 数组很不一样。 这里 vis 数组只是避免同一个点已经在队列里的情况下被加入队列多次而用的（再次强调，SPFA 是允许一个点多次入列的，只不过正在队列里的，确实没必要再入列了）。 那么具体看这道题，dis[i][j]表示到达第 i 行第 j 列的点所需要的最小花费，直接的状态转移看上去并不好想。 怎么办？ 不好想就不想了呗！ 只要某个点 dis 变得更小了，我们按照 SPFA 的思想，就二话不说给他入列，让他再更新周围点的dis，这样总是对的了吧。 所以说白了，SPFA，听上去高大上，其实是贼暴力的一种方法，只要检测到某点 dis 值改变，就在重新由这点开始 BFS，仅此而已。 代码 下面是代码： 1234567891011121314151617181920212223242526272829303132333435363738#define INF 10005int dis[105][105];bool inQue[105][105];int dx[]={0,0,0,1,-1};int dy[]={0,1,-1,0,0};class Solution {public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n=grid.size();int m=grid[0].size(); memset(dis,INF,sizeof(dis)); memset(inQue,false,sizeof(inQue)); queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(0,0)); inQue[0][0]=true; dis[0][0]=0; while(!q.empty()){ auto now=q.front();q.pop(); int x=now.first;int y=now.second; inQue[x][y]=false; for(int k=1;k&lt;5;k++){ if(x+dx[k]&lt;0||x+dx[k]&gt;=n||y+dy[k]&lt;0||y+dy[k]&gt;=m)continue; int val= k==grid[x][y]?dis[x][y]:dis[x][y]+1; if(dis[x+dx[k]][y+dy[k]]&gt;val){ dis[x+dx[k]][y+dy[k]]=val; if(!inQue[x+dx[k]][y+dy[k]]){ q.push(make_pair(x+dx[k],y+dy[k])); inQue[x+dx[k]][y+dy[k]]=true; } } } } return dis[n-1][m-1]; }}; &nbsp;&nbsp; 王希孟千里江山图卷","link":"/SPFA-BFS%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A9%E5%B1%95/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}