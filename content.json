{"pages":[],"posts":[{"title":"SPFA-BFS的一种扩展","text":"一句话总结本篇题解内容:BFS中每个点只入列一次，但有时，我们可能需要BFS中允许一个点入列多次才能解决问题，这种方法就是SPFA。 简介SPFA这种算法，如果你百度的话，你会发现大多是说他用于求最短路的，事实上，更宽泛的来理解，所有“可能要后悔”的BFS，都可以用类似SPFA的思路来解决。 先说说经典的最短路问题，希望大家能借此理解为何说SPFA是可以“后悔”的。 经典问题 考虑这样一张图，1号点是起点，边上的数字代表这条边的长度，你想求出1到10号点的最短路。 下面，说说为何朴素的BFS不行。 按照BFS的流程，初始1号点入列，然后1号点周围的2号和3号入列。此时，2距1最短路更新为4,3距1最短路更新为1。 于是，问题来了，我们看到，实际上1到2的最短路是1-&gt;3-&gt;4-&gt;2，其长度为3。 但按照朴素的BFS来做，由于已经有vis[2]=1了，所以由4号点访问周围点时，2号点就不会再入列了，这样，我们就会求出错误的最短路。 那怎么办呢？一个很显然的办法，就是——那我就再把2入列呗！ SPFA算法所以，SPFA其实就是很简单的一件事儿：检测到某点距离变化，就把某点入列。 并且如前所述，这样的SPFA其实就不需要vis数组了，因为只要距离更新，点就要入列。 但下面代码中还是有vis数组，其实他的含义是：某个点当前正在队列里，vis值为1，当前点不在队列里，vis值为0。 需要注意，虽然名字都叫vis，但这里的vis数组和朴素BFS中的vis数组很不一样。 这里vis数组只是避免同一个点已经在队列里的情况下被加入队列多次而用的（再次强调，SPFA是允许一个点多次入列的，只不过正在队列里的，确实没必要再入列了）。 那么具体看这道题，dis[i][j]表示到达第i行第j列的点所需要的最小花费，直接的状态转移看上去并不好想。 怎么办？ 不好想就不想了呗！ 只要某个点dis变得更小了，我们按照SPFA的思想，就二话不说给他入列，让他再更新周围点的dis，这样总是对的了吧。 所以说白了，SPFA，听上去高大上，其实是贼暴力的一种方法，只要检测到某点dis值改变，就在重新由这点开始BFS，仅此而已。 代码下面是代码： 1234567891011121314151617181920212223242526272829303132333435363738#define INF 10005int dis[105][105];bool inQue[105][105];int dx[]={0,0,0,1,-1};int dy[]={0,1,-1,0,0};class Solution {public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n=grid.size();int m=grid[0].size(); memset(dis,INF,sizeof(dis)); memset(inQue,false,sizeof(inQue)); queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(0,0)); inQue[0][0]=true; dis[0][0]=0; while(!q.empty()){ auto now=q.front();q.pop(); int x=now.first;int y=now.second; inQue[x][y]=false; for(int k=1;k&lt;5;k++){ if(x+dx[k]&lt;0||x+dx[k]&gt;=n||y+dy[k]&lt;0||y+dy[k]&gt;=m)continue; int val= k==grid[x][y]?dis[x][y]:dis[x][y]+1; if(dis[x+dx[k]][y+dy[k]]&gt;val){ dis[x+dx[k]][y+dy[k]]=val; if(!inQue[x+dx[k]][y+dy[k]]){ q.push(make_pair(x+dx[k],y+dy[k])); inQue[x+dx[k]][y+dy[k]]=true; } } } } return dis[n-1][m-1]; }}; &nbsp;&nbsp; 王希孟千里江山图卷","link":"/SPFA-BFS%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A9%E5%B1%95/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}