{"pages":[{"title":"","text":"关于作者 重庆土著，现居苏州，2020 年毕业于重庆理工大学计算机科学与技术专业，目前中国科学技术大学软件工程研究生在读 预备役程序员，喜欢捣鼓各种和计算机相关的酷玩意儿 狂热足球爱好者，主队重庆当代、阿森纳、荷兰，兹拉坦迷弟，所以也会看 AC 米兰的比赛 技能树 Java- 熟悉 SpringBoot、SpringCloud，了解 Redis 缓存相关、MyBatis、JBA 数据库相关， 学过一点 Android（做过一些简单的 APP），近期准备从 Java 基础知识开始梳理一下，同时学习一下 JVM 和 MQ 消息队列相关 前端- 熟悉前端三剑客，常用 Vue.js，了解 React.js、Webpack 相关，用过 Sass、Echarts.js Python- 了解爬虫相关，用过 Flask 框架搭建后台，了解机器学习相关，使用过 numpy、pandas、sklearn 等，本科毕业设计用 Opencv+Keras 做过 CNN 手势识别交互系统 其他- 熟悉 Git 操作，了解 Linux 命令，用过 Docker，了解过 SQL 优化 语言- 英语六级（584 分），明年找到实习后准备考雅思，学过一点德语 项目 TODO 获奖 TODO","link":"/about/index.html"}],"posts":[{"title":"SPFA-BFS 的一种扩展","text":"一句话总结本篇题解内容:BFS 中每个点只入列一次，但有时，我们可能需要 BFS 中允许一个点入列多次才能解决问题，这种方法就是 SPFA。 简介SPFA 这种算法，如果你百度的话，你会发现大多是说他用于求最短路的，事实上，更宽泛的来理解，所有“可能要后悔”的 BFS，都可以用类似 SPFA 的思路来解决。 先说说经典的最短路问题，希望大家能借此理解为何说 SPFA 是可以“后悔”的。 经典问题 考虑这样一张图，1 号点是起点，边上的数字代表这条边的长度，你想求出 1 到 10 号点的最短路。 下面，说说为何朴素的 BFS 不行。 按照 BFS 的流程，初始 1 号点入列，然后 1 号点周围的 2 号和 3 号入列。此时，2 距 1 最短路更新为 4,3 距 1 最短路更新为 1。 于是，问题来了，我们看到，实际上 1 到 2 的最短路是1-&gt;3-&gt;4-&gt;2，其长度为 3。 但按照朴素的 BFS 来做，由于已经有 vis[2]=1 了，所以由 4 号点访问周围点时，2 号点就不会再入列了，这样，我们就会求出错误的最短路。 那怎么办呢？一个很显然的办法，就是——那我就再把 2 入列呗！ SPFA 算法 所以，SPFA 其实就是很简单的一件事儿：检测到某点距离变化，就把某点入列。 并且如前所述，这样的 SPFA 其实就不需要 vis 数组了，因为只要距离更新，点就要入列。 但下面代码中还是有 vis 数组，其实他的含义是：某个点当前正在队列里，vis值为 1，当前点不在队列里，vis值为 0。 需要注意，虽然名字都叫 vis，但这里的vis 数组和朴素 BFS 中的 vis 数组很不一样。 这里 vis 数组只是避免同一个点已经在队列里的情况下被加入队列多次而用的（再次强调，SPFA 是允许一个点多次入列的，只不过正在队列里的，确实没必要再入列了）。 那么具体看这道题，dis[i][j]表示到达第 i 行第 j 列的点所需要的最小花费，直接的状态转移看上去并不好想。 怎么办？ 不好想就不想了呗！ 只要某个点 dis 变得更小了，我们按照 SPFA 的思想，就二话不说给他入列，让他再更新周围点的dis，这样总是对的了吧。 所以说白了，SPFA，听上去高大上，其实是贼暴力的一种方法，只要检测到某点 dis 值改变，就在重新由这点开始 BFS，仅此而已。 代码 下面是代码： 1234567891011121314151617181920212223242526272829303132333435363738#define INF 10005int dis[105][105];bool inQue[105][105];int dx[]={0,0,0,1,-1};int dy[]={0,1,-1,0,0};class Solution {public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n=grid.size();int m=grid[0].size(); memset(dis,INF,sizeof(dis)); memset(inQue,false,sizeof(inQue)); queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(0,0)); inQue[0][0]=true; dis[0][0]=0; while(!q.empty()){ auto now=q.front();q.pop(); int x=now.first;int y=now.second; inQue[x][y]=false; for(int k=1;k&lt;5;k++){ if(x+dx[k]&lt;0||x+dx[k]&gt;=n||y+dy[k]&lt;0||y+dy[k]&gt;=m)continue; int val= k==grid[x][y]?dis[x][y]:dis[x][y]+1; if(dis[x+dx[k]][y+dy[k]]&gt;val){ dis[x+dx[k]][y+dy[k]]=val; if(!inQue[x+dx[k]][y+dy[k]]){ q.push(make_pair(x+dx[k],y+dy[k])); inQue[x+dx[k]][y+dy[k]]=true; } } } } return dis[n-1][m-1]; }}; &nbsp;&nbsp; 王希孟千里江山图卷","link":"/SPFA-BFS%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A9%E5%B1%95/"},{"title":"最小生成树代码存档 -prim 和 kruskal","text":"最小生成树代码存档，基于《算法笔记》中的代码，方便以后查看使用。 prim 算法 伪代码 12345678910111213//G 为图，一般设成全局变量，数组 d 为顶点与集合 s 的最短距离Prim(G,d[]){ 初始化; for(循环 n 次){ u= 使 d[u] 最小的未被访问的顶点的标号; 记 u 已被访问; for(从 u 出发能够到达的所有顶点 v){ if(v 未被访问 &amp;&amp; 以 u 为中介点使得 v 与集合 s 的最短距离 d[v]更优){ 将 G[u][v]赋值给 v 与集合 s 的最短距离 d[v]; } } }} 邻接数组代码 123456789101112131415161718192021222324252627282930int n,G[MAXN][MAXN]; //n 为顶点数，MAXN 为最大顶点数int d[MAXN]; // 顶点与集合 s 的最短距离bool vis[MAXN]={false}; // 标记数组，vis[i]==true 表示已访问。初值为 falseint prim(){ // 默认 0 号为初始点，函数返回最小生成树的边权之和 fill(d,d+MAXN,INF); //fill 函数将整个 d 数组赋为 INF（慎用 memset） d[0]=0; // 只有 0 号顶点到集合 s 的距离为 0，其余全为 INF int ans=0 // 存放最小生成树的边权之和 for(int i=0;i&lt;n;i++){ // 循环 n 次 int u=-1,MIN=INF; //u 使 d[u] 最小,MIN 存放该最小的 d[u] for(int j=0;j&lt;n;j++){ // 找到未访问的顶点中 d[]最小的 if(vis[j]==false &amp;&amp; d[j]&lt;MIN){ u=j; MIN=d[j]; } } // 找不到小于 INF 的 d[u]，则剩下的顶点和集合 s 不连通 if(u==-1) return -1; vis[u]=true; // 标记 u 为已访问 ans+=d[u]; // 将与集合 s 距离最小的边加入生成树 for(int v=0;v&lt;n;v++){ //v 未访问 &amp;&amp; u 能到达 v &amp;&amp; 以 u 为中介点可以使 v 离集合 s 更近 if(vis[v]==false &amp;&amp; G[u][v] != INF &amp;&amp; G[u][v]&lt;d[v]){ d[v]=G[u][v]; // 将 G[u][v] 赋值给 d[v] } } } return ans;} 邻接表代码 12345678910111213141516171819202122232425262728293031323334353637struct Node{ int v,dis; //v 为边的目标顶点，dis 为边权};vector&lt;Node&gt; Adj[MAXN]; // 图 G，Adj[u] 存放从顶点 u 出发的可以到达的所有顶点 int n; //n 为顶点数，图 G 使用邻接表实现，MAXN 为最大顶点数int d[MAXN]; // 顶点与集合 s 的最短距离bool vis[MAXN]={false}; // 标记数组，vis[i]==true 表示已访问。初值为 falseint prim(){ // 默认 0 号为初始点，函数返回最小生成树的边权之和 fill(d,d+MAXN,INF); //fill 函数将整个 d 数组赋为 INF（慎用 memset） d[0]=0; // 只有 0 号顶点到集合 s 的距离为 0，其余全为 INF int ans=0 // 存放最小生成树的边权之和 for(int i=0;i&lt;n;i++){ // 循环 n 次 int u=-1,MIN=INF; //u 使 d[u] 最小,MIN 存放该最小的 d[u] for(int j=0;j&lt;n;j++){ // 找到未访问的顶点中 d[]最小的 if(vis[j]==false &amp;&amp; d[j]&lt;MIN){ u=j; MIN=d[j]; } } // 找不到小于 INF 的 d[u]，则剩下的顶点和集合 s 不连通 if(u==-1) return -1; vis[u]=true; // 标记 u 为已访问 ans+=d[u]; // 将与集合 s 距离最小的边加入生成树 // 只有下面这个 for 与邻接矩阵写法不同 for(int j=0;j&lt;Adj[u].size();j++){ int v=Adj[u][j].v; if(vis[v]==false &amp;&amp; Adj[u][j].dis&lt;d[v]){ // 如果 vw 未访问 &amp;&amp; 以 u 为中介点可以使 v 离集合 s 更近 d[v]=G[u][v]; // 将 G[u][v] 赋值给 d[v] } } } return ans;} kruskal 算法 伪代码 12345678910111213int kruskal(){ 令最小生成树的边权之和为 ans、最小生成树的当前边数 Num_Edge; 将所有边按边权从小到大排序; for(从小到大枚举所有边){ if(当前测试边的两个端点在不同的连通块中){ 将该测试边加入最小生成树中; ans += 测试边的边权; 最小生成树的当前边数 Num_Edge 加1; 当边数 Num_Edge 等于顶点数减1 时循环结束; } } return ans;} 代码12345678910111213141516171819202122232425262728293031323334353637383940// 边集定义部分struct edge{ int u,v; // 边的两个端点编号 int cost; // 边权}E[MAXE]; // 最多有 MAXE 条边bool cmp(edge a,edge b){ return a.cost&lt;b.cost;}// 并查集部分int father[MAXN];int findFather(int x){ if(x!=father[x]) return father[x]=findFather(father[x]); return x;}//kruskal 部分，返回最小生成树的边权之和，参数 n 为顶点个数，m 为图的边数int kruskal(){ int ans=0,Num_Edge=0; for(int i=0;i&lt;n;i++){ father[i]=i; } sort(E,E+m,cmp); for(int i=0;i&lt;m;i++){ int faU=findFather(E[i].u); int faV=findFather(E[i].v); if(faU!=faV){ father[faU]=faV; ans+=E[i].cost; Num_Edge++; if(Num_Edge==n-1)break; } } if(Num_Edge!=n-1) return -1; return ans;}","link":"/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E4%BB%A3%E7%A0%81%E5%AD%98%E6%A1%A3-prim%E5%92%8Ckruskal/"}],"tags":[{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"SPFA","slug":"SPFA","link":"/tags/SPFA/"},{"name":"BFS","slug":"BFS","link":"/tags/BFS/"},{"name":"最小生成树","slug":"最小生成树","link":"/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"},{"name":"prim","slug":"prim","link":"/tags/prim/"},{"name":"kruskal","slug":"kruskal","link":"/tags/kruskal/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"代码归档","slug":"算法/代码归档","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BB%A3%E7%A0%81%E5%BD%92%E6%A1%A3/"}]}