{"pages":[],"posts":[{"title":"Hello World","text":"Hello, world.","link":"/2018/07/24/blog1/"},{"title":"ATOM报错Cannot load the system dictionary for zh-CN","text":"新换了电脑，配置开发环境的时候遇到很多问题。。ATOM每次打开都会报错，提示Cannot load the system dictionary for zh-CN. 打开提示的文件夹，发现里面有三个文件： 查了一下Hanspell是用来做拼写检查的。 然后打开Atom-Files-Settings-Packages搜索spell check，发现了这个spell-check的插件。 点Settings进去，发现设置里会根据系统语言自己选择相应的拼写检查设置文件，然而文件夹中只有en-US的设置，所以有两个选择可以解决这个问题 取消掉Use Locales前面的勾选 或者 手动填写en-US设置文件名称","link":"/2018/07/24/blog2/"},{"title":"Leetcode刷题第一天","text":"在知乎上看见很多大神都推荐找工作之前尽量刷完LeetCode上面的题目，LeetCode相对于ACM的题目来说是相对简单而且其中的题目又是一些非常经典的题目。所以从今天开始希望自己每天都能够在LeetCode上面刷几道题目。 第一题简单的暴力算法（但是排名好像有点低也。。。） 123456789101112131415class Solution { public int[] twoSum(int[] nums, int target) { int[] rs=new int[2]; for(int i=0;i&lt;nums.length;i++) { for(int j=i+1;j&lt;nums.length;j++) { if((nums[i]+nums[j])==target) { rs[0]=i; rs[1]=j; return rs; } } } return null; }} 第二题没有一次性过，报了这个错误:member access within misaligned address 0x000000000031 for type ‘struct ListNode’, which requires 8 byte alignment 由于结构体内存在next指针，而申请结构体空间后同时定义了next指针，此时next指针未指向任何空间，故在测试时可能导致上述错误。解决方法为：增加代码使next指针指向空。 node-&gt;next=NULL; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566struct ListNode { int val; struct ListNode *next;};struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) { int t=0; struct ListNode* l3=(struct ListNode*)malloc(sizeof(struct ListNode)); l3-&gt;next=NULL; struct ListNode* q=l3; while(l1!=NULL &amp;&amp; l2!=NULL){ struct ListNode* node=(struct ListNode*)malloc(sizeof(struct ListNode)); node-&gt;next=NULL; node-&gt;val=l1-&gt;val+l2-&gt;val+t; if(node-&gt;val&gt;=10){ node-&gt;val=node-&gt;val%10; t=1; }else{ t=0; } q-&gt;next=node; q=node; l1=l1-&gt;next; l2=l2-&gt;next; } if(l2==NULL &amp;&amp; l1!=NULL){ while(l1!=NULL){ struct ListNode* node=(struct ListNode*)malloc(sizeof(struct ListNode)); node-&gt;next=NULL; node-&gt;val=l1-&gt;val+t; if(node-&gt;val&gt;=10){ node-&gt;val=node-&gt;val%10; t=1; }else{ t=0; } l1=l1-&gt;next; q-&gt;next=node; q=node; } }else if(l2!=NULL &amp;&amp; l1==NULL){ while(l2!=NULL){ struct ListNode* node=(struct ListNode*)malloc(sizeof(struct ListNode)); node-&gt;next=NULL; node-&gt;val=l2-&gt;val+t; l2=l2-&gt;next; if(node-&gt;val&gt;=10){ node-&gt;val=node-&gt;val%10; t=1; }else{ t=0; } q-&gt;next=node; q=node; } } if(t==1){ struct ListNode* node=(struct ListNode*)malloc(sizeof(struct ListNode)); node-&gt;next=NULL; node-&gt;val=t; q-&gt;next=node; q=node; t=0; } return l3-&gt;next;}","link":"/2018/08/09/blog3/"},{"title":"Leetcode刷题第二天","text":"第三题经典字符串问题，java排名依据很低 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public int lengthOfLongestSubstring(String s) { int n = 0; int k = 0; int flag = 0; if (s == null) { return 0; } if (s.length() == 1) { return 1; } for (int i = 0; i &lt; s.length(); i++) { if(s.length()-i&lt;=k) { break; } k = 0; if (flag == 1) { break; } for (int j = i + 1; j &lt; s.length(); j++) { k++; if (s.substring(i, j).contains(s.substring(j, j + 1))) { if (k &gt; n) { n = k; } break; } if (j == s.length() - 1) { flag = 1; if (k + 1 &gt; n) { n = k + 1; } break; } } } return n; }} 第四题给定两个大小为 m 和 n 的有序数组 nums1 和 nums2 。请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n))。你可以假设 nums1 和 nums2 均不为空。 1234567891011121314151617181920212223242526272829class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { double rs=0; int len=nums1.length+nums2.length; int[] nums3=new int[len]; int i=0,j=0; int k=0; while(i&lt;nums1.length &amp;&amp; j&lt;nums2.length) { if(nums1[i]&lt;nums2[j]) { nums3[k++]=nums1[i++]; }else { nums3[k++]=nums2[j++]; } } while(i&lt;nums1.length) { nums3[k++]=nums1[i++]; } while(j&lt;nums2.length){ nums3[k++]=nums2[j++]; } if(len%2==0) { rs=(nums3[(len-1)/2]+nums3[((len-1)/2)+1]+0.0)/2; } else { rs=nums3[len/2]; } return rs; }} 第五题依旧字符串经典题目，最长回文子串，暴力算法，排名依旧低这题做的各种特判，还有最后修修补补凑出来的程序居然通过了，有空这道题要好好改改再做一次 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution { public String longestPalindrome(String s) { if (s == null || &quot;&quot;.equals(s)) { return s; } int pos=1; int left=0; int right=0; String rs=s.substring(0,1); if(s.length()&gt;=2 &amp;&amp; s.substring(0,1).equals(s.substring(1,2))) { rs=s.substring(0,2); } for(int i=1;i&lt;s.length()-1;i++) { left=i; right=i+pos; if(rs.length()&lt;2 &amp;&amp; s.substring(i,i+1).equals(s.substring(right,right+1))) { rs=s.substring(i,right+1); } while(left&gt;=0 &amp;&amp; right&lt;s.length()) { if(!s.substring(left,left+1).equals(s.substring(right,right+1))) { break; } if(rs.length()&lt;=s.substring(left, right+1).length()) { rs=s.substring(left,right+1); } left=left-pos; right=right+pos; } left=i-pos; right=i+pos; if(rs.length()&lt;2 &amp;&amp; s.substring(i,i+1).equals(s.substring(right,right+1))) { rs=s.substring(i,right+1); } while(left&gt;=0 &amp;&amp; right&lt;s.length()) { if(!s.substring(left,left+1).equals(s.substring(right,right+1))) { break; } if(rs.length()&lt;=s.substring(left, right+1).length()) { rs=s.substring(left,right+1); } left=left-pos; right=right+pos; } } return rs; }}","link":"/2018/08/10/blog4/"},{"title":"Leetcode刷题第三天","text":"今天有点偷懒，看网课也是，做题也是，哈哈，今天可能不适合学习吧。。。偷懒的时候看了一下考研英语圣经——恋练有词，挺不错的，朱老师很棒！ 第六题Z字型数，好像在看java web网课的时候离下课还有点时间老师讲过这道题，还说是面试题，哈哈但是解法完全记不得了，今天做的时候又重新推了一遍，java排名依据很低 1234567891011121314151617181920212223242526272829class Solution { public String convert(String s, int numRows) { boolean flag=true; if(s==null || &quot;&quot;.trim().equals(s)) { return s; } List&lt;StringBuffer&gt; list=new ArrayList&lt;&gt;(); for(int i=0;i&lt;numRows;i++) { list.add(new StringBuffer()); } int n=0; for(int i=0;i&lt;s.length();i++) { if((i+n)%numRows==0 &amp;&amp; i!=0) { flag=!flag; n++; } if(flag) { list.get((i+n)%numRows).append(s.substring(i,i+1)); }else { list.get((numRows-1)-((i+n)%numRows)).append(s.substring(i,i+1)); } } StringBuffer rs=new StringBuffer(); for(StringBuffer sb:list) { rs.append(sb); } return rs.toString(); }} 第七题这题开始把范围看错了，-2的31次方写成2的-31次方也是醉了。。。 1234567891011121314151617181920212223class Solution { public int reverse(int x) { int arr[]=new int[100]; if(x==0) { return 0; } int i=0; while(x!=0) { arr[i]=x%10; x=x/10; i++; } int rs = 0; for(int j=0;j&lt;i;j++) { rs+=Math.pow(10, i-1-j)*arr[j]; if(rs&gt;=(Math.pow(2, 31)-1)||rs&lt;=(Math.pow(-2, 31))) { rs=0; break; } } return rs; }}","link":"/2018/08/11/blog5/"},{"title":"Leetcode刷题第四天","text":"今天完全忘记了早上有Leetcode的比赛，哈哈，后面只有做了虚拟赛，结果四道题只做起一道，自己真的好菜啊。话说竞赛第一名来自日本的uwi，好像在很多地方都看见过此人的身影，抽空去了解一下这位大神。今天做了四道题，今天的题挺简单的 第八题实现 atoi，将字符串转为整数。 1234567891011121314151617181920212223242526272829303132333435import java.util.regex.*;class Solution { public int myAtoi(String str) { if(str==null || str.replaceAll(&quot; &quot;, &quot;&quot;).equals(&quot;&quot;) || str.replaceAll(&quot; &quot;,&quot;&quot;).equals(&quot;-&quot;)) { return 0; } str=str.trim(); String pattern=&quot;^([-||'+'])?[0-9]+.*$&quot;; boolean isMatch = Pattern.matches(pattern, str); if(!isMatch) { return 0; } int len=0; for(int i=0;i&lt;str.length();i++) { if(!Character.isDigit(str.charAt(i)) &amp;&amp; i!=0){ len=i; break; } } if(len==0) { len=str.length(); } int rs=0; if(Double.parseDouble(str.substring(0, len))&gt;Integer.MAX_VALUE) { rs=Integer.MAX_VALUE; } else if(Double.parseDouble(str.substring(0, len))&lt;Integer.MIN_VALUE) { rs=Integer.MIN_VALUE; } else { rs=Integer.parseInt(str.substring(0, len)); } return rs; }} 第九题判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 12345678910111213class Solution { public boolean isPalindrome(int x) { boolean flag=true; String a=String.valueOf(x); for(int i=0;i&lt;a.length()/2;i++) { if(a.charAt(i)!=a.charAt(a.length()-1-i)) { flag=false; break; } } return flag; }} 第十题 1234567import java.util.regex.Pattern;class Solution { public boolean isMatch(String s, String p) { boolean rs=Pattern.matches(p, s); return rs; }} 第十一题这道题暴力解法连排行榜都上不了。。。 12345678910111213141516171819202122232425262728293031323334class Solution { public int maxArea(int[] height) { if(height.length==0) { return 0; } int n=0; for(int i=0;i&lt;height.length;i++) { if(height[i]&gt;0) { n++; if(n&gt;1) { break; } } } if(n&lt;=1) { return 0; } int rs=0; int temp; for(int i=0;i&lt;height.length;i++) { for(int j=i+1;j&lt;height.length;j++) { if(height[j]&lt;=height[i]) { temp=height[j]*(j-i); }else { temp=height[i]*(j-i); } if(temp&gt;rs) { rs=temp; } } } return rs; }}","link":"/2018/08/12/blog6/"},{"title":"Leetcode刷题第五天","text":"今天是两道类似的题，罗马数字转整数，整数转罗马数字，仿佛大一acm校赛的那道签到题——需要多少枚硬币，典型的贪心法最近想学一下C++和STL好为下学期的重庆市程序设计大赛做准备明天去图书馆看一下有没有信息学竞赛一本通 第十二题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution { public String intToRoman(int num) { // I 1 // V 5 // X 10 // L 50 // C 100 // D 500 // M 1000 Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, &quot;I&quot;); map.put(5, &quot;V&quot;); map.put(10, &quot;X&quot;); map.put(50, &quot;L&quot;); map.put(100, &quot;C&quot;); map.put(500, &quot;D&quot;); map.put(1000, &quot;M&quot;); StringBuffer sb = new StringBuffer(); int i = 1; int k=1000; while (num!= 0) { while (num - i * k &gt;= 0) { i++; } i=i-1; if(i==4) { sb.append(map.get(k)); sb.append(map.get(5*k)); } if(i&lt;4) { while(i&gt;0) { sb.append(map.get(k)); i--; } } if(i==9) { sb.append(map.get(k)); sb.append(map.get(k*10)); } if(4&lt;i&amp;&amp;i&lt;9) { i=i-5; sb.append(map.get(5*k)); while(i&gt;0) { sb.append(map.get(k)); i--; } } i = 1; num = num % k; k=k/10; } return sb.toString(); }} 第十三题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public int romanToInt(String s) { // I 1 // V 5 // X 10 // L 50 // C 100 // D 500 // M 1000 Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int i, j = 0; int rs = 0; char a; int flag = 0; for (i = 0; i &lt; s.length(); i = j) { flag = 0; a = s.charAt(i); for (j = i + 1; j &lt; s.length(); j++) { flag = 1; if (s.charAt(j) != a) { break; } } if(flag==0 &amp;&amp; j==s.length()) { rs += map.get(s.charAt(i)); } if (flag == 1) { if (j == s.length()) { rs += map.get(s.charAt(i)) * (j - i); } else if (map.get(s.charAt(j))&gt;map.get(s.charAt(i))) { rs += map.get(s.charAt(j)) - map.get(s.charAt(i)) * (j - i); j++; } else { rs += map.get(s.charAt(i)) * (j - i); } } } return rs; }}","link":"/2018/08/13/blog7/"},{"title":"Leetcode刷题第六天","text":"今天第一次被难住，自己习以为常的暴力法终于遭遇了超时的这一致命的打击！今天的一道看似简单的三数之和为0的题目却让我发现了自己真的好菜看了别人写的代码瞬间惊为天人，智商受到了碾压，做算法竞赛的人究竟是有多聪明呢？ 第十四题 123456789101112131415161718192021222324252627282930class Solution { public String longestCommonPrefix(String[] strs) { if(strs.length==0 || strs==null) { return &quot;&quot;; } int flag=0; String sb=&quot;&quot;; String stemp=null; int min=10000; for(String s:strs) { min=Math.min(s.length(), min); if(min==s.length()) { stemp=s; } } for(int i=0;i&lt;min;i++) { for(String s:strs) { if(!stemp.substring(0,i+1).equals(s.substring(0,i+1))) { flag=1; break; } } if(flag==1) { break; } sb=(stemp.substring(0,i+1)); } return sb; }} 第十五题 12345678910111213141516171819202122232425262728293031323334353637class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { List&lt;List&lt;Integer&gt;&gt; rs=new ArrayList&lt;&gt;(); Arrays.sort(nums); //只用找到倒数第三个 for(int i=0;i+2&lt;nums.length;i++) { //最牛逼的地方！只有是【-1，-1，2】这种情况才可能组合起来为0，而例如【-2，-1，-1，2】这种情况不会被遗漏 if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) { //skip same result continue; } int j=i+1,k=nums.length-1; //目标数字 int target=-nums[i]; while(j&lt;k) { if(nums[j]+nums[k]==target) { rs.add(Arrays.asList(nums[i],nums[j],nums[k])); j++; k--; //skip same result while(j&lt;k&amp;&amp;nums[j]==nums[j-1]) j++; while(j&lt;k&amp;&amp;nums[k]==nums[k+1]) { k--; } } //继续搜素 else if(nums[j]+nums[k]&gt;target){ k--; }else { j++; } } } return rs; }}","link":"/2018/08/14/blog8/"},{"title":"Leetcode刷题第七天","text":"今天做了昨天三数之和的改版题四数之和，完全自己写的也彻底明白了其中的精髓明天要出去七夕节约会不知道能不能写了，可能要休假一天，哈哈哈 第十六题 12345678910111213141516171819class Solution { public int threeSumClosest(int[] nums, int target) { int rs=10086; int result=0; for(int i=0;i&lt;nums.length;i++) { for(int j=i+1;j&lt;nums.length;j++) { for(int k=j+1;k&lt;nums.length;k++) { int sum=nums[i]+nums[j]+nums[k]; int temp=Math.abs(target-sum); if(temp&lt;rs){ rs=temp; result=sum; } } } } return result; }} 第十七题 1234567891011121314151617181920212223242526272829303132333435363738class Solution { Map&lt;Character,String&gt; map=new HashMap&lt;&gt;(); List&lt;String&gt; list=new ArrayList&lt;&gt;(); public List&lt;String&gt; letterCombinations(String digits) { if(digits==null||&quot;&quot;.equals(digits)) return list; map.put('2', &quot;abc&quot;); map.put('3', &quot;def&quot;); map.put('4', &quot;ghi&quot;); map.put('5', &quot;jkl&quot;); map.put('6', &quot;mno&quot;); map.put('7', &quot;pqrs&quot;); map.put('8', &quot;tuv&quot;); map.put('9', &quot;wxyz&quot;); String[] a=new String[digits.length()]; for(int i=0;i&lt;digits.length();i++) { a[i]=map.get(digits.charAt(i)); } StringBuffer sb=new StringBuffer(); fun(0,digits.length(),sb,a); return list; } public void fun(int level,int total,StringBuffer sb,String[] a) { if(level==total) { list.add(sb.toString()); return; } for(int i=0;i&lt;a[level].length();i++) { sb.append(a[level].charAt(i)); fun(level+1,total,sb,a); sb.deleteCharAt(level); } }} 第十八题 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) { List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); int i, j; for (i = 0; i &lt; nums.length - 3; i++) { if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) { continue; } for (j = i + 1; j &lt; nums.length - 2; j++) { if (j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) { continue; } int temp = target - nums[i] - nums[j]; int k = j + 1; int m = nums.length - 1; while (k &lt; m) { if (nums[k] + nums[m] == temp) { list.add(Arrays.asList(nums[i], nums[j], nums[k], nums[m])); k++; m--; while (k &lt; m &amp;&amp; nums[m] == nums[m + 1]) { m--; } while (k &lt; m &amp;&amp; nums[k] == nums[k - 1]) { k++; } } else if (nums[k] + nums[m] &gt; temp) { m--; } else { k++; } } } } return list; }}","link":"/2018/08/15/blog9/"},{"title":"Leetcode刷题第八天","text":"Though day. 第十九题 12345678910111213141516171819202122232425262728/*** Definition for singly-linked list.* struct ListNode {* int val;* struct ListNode *next;* };*/struct ListNode* removeNthFromEnd(struct ListNode* head, int n) { if(head-&gt;next==NULL){ return NULL; } struct ListNode* p=head; struct ListNode* q=head; int i=0; for(i=0;i&lt;n;i++){ q=q-&gt;next; } while(q!=NULL &amp;&amp; q-&gt;next!=NULL){ p=p-&gt;next; q=q-&gt;next; } if(q==NULL &amp;&amp; head==p){ head=p-&gt;next; }else{ p-&gt;next=p-&gt;next-&gt;next; } return head;} 第二十题 123456789101112131415161718192021222324252627282930class Solution { public boolean isValid(String s) { if(s==null||&quot;&quot;.trim().equals(s)){ return true; } int flag=1; int a=0; char[] crr=new char[10000]; Map&lt;Character,Character&gt; map=new HashMap&lt;&gt;(); map.put('(', ')'); map.put('{','}'); map.put('[',']'); for(int i=0;i&lt;s.length();i++) { if(s.charAt(i)=='('||s.charAt(i)=='['||s.charAt(i)=='{') { crr[a]=s.charAt(i); a++; flag=0; } else if(a&gt;0 &amp;&amp; map.get(crr[a-1])==s.charAt(i)) { a--; }else{ flag=1; break; } } if(a==0&amp;&amp;flag==0) return true; return false; }}","link":"/2018/08/16/blog10/"},{"title":"Leetcode刷题第九天","text":"七夕节，疲惫却幸福爆棚的一天 第二十一题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** Definition for singly-linked list.* struct ListNode {* int val;* struct ListNode *next;* };*/struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) { if(l1==NULL &amp;&amp; l2==NULL){ return NULL; } struct ListNode* h=(struct ListNode*)malloc(sizeof(struct ListNode)); h-&gt;next=NULL; struct ListNode* p=h; while(l1!=NULL&amp;&amp;l2!=NULL){ struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode)); q-&gt;next=NULL; if(l1-&gt;val&lt;l2-&gt;val){ p-&gt;val=l1-&gt;val; l1=l1-&gt;next; }else{ p-&gt;val=l2-&gt;val; l2=l2-&gt;next; } p-&gt;next=q; p=q; } while(l1!=NULL){ p-&gt;val=l1-&gt;val; l1=l1-&gt;next; if(l1!=NULL){ struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode)); q-&gt;next=NULL; p-&gt;next=q; p=q; } } while(l2!=NULL){ p-&gt;val=l2-&gt;val; l2=l2-&gt;next; if(l2!=NULL){ struct ListNode* q=(struct ListNode*)malloc(sizeof(struct ListNode)); q-&gt;next=NULL; p-&gt;next=q; p=q; } } return h;} 第二十二题 123456789101112131415161718192021222324252627class Solution { List&lt;String&gt; list=new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) { fun('(',new StringBuffer(),0,n); return list; } public void fun(char a,StringBuffer sb,int i,int n) { if(sb.length()==2*n&amp;&amp;i==0&amp;&amp;a==')') { list.add(sb.toString()); return; } if(sb.length()==2*n || i&lt;0 || i&gt;n) { return; } if('('==a) { i=i+1; }else { i=i-1; } sb.append(a); fun('(',sb,i,n); fun(')',sb,i,n); sb.deleteCharAt(sb.length()-1); }}","link":"/2018/08/17/blog11/"},{"title":"Leetcode刷题第十天","text":"今天被链表虐哭，还有很长的路要走，看了ACM World Final,智商真的是硬伤第一次用java写链表题，感觉还可以 第二十三题 1234567891011121314151617181920212223242526272829303132333435/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode mergeKLists(ListNode[] lists) { ListNode res=new ListNode(0); res.next=null; ListNode h=res; for(int i=0;i&lt;lists.length;i++) { ListNode tmp=lists[i]; if(res.next==null &amp;&amp; i==0) { res.next=tmp; continue; } while(tmp!=null) { h=res; while(tmp!=null&amp;&amp;h.next!=null&amp;&amp;tmp.val&gt;h.next.val) { h=h.next; } if(tmp!=null) { ListNode add=new ListNode(tmp.val); add.next=h.next; h.next=add; } tmp=tmp.next; } } return res.next; }} 第二十四题 12345678910111213141516171819202122232425262728293031323334353637/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode swapPairs(ListNode head) { if(head==null){ return null; } ListNode p=head; ListNode q=p.next; ListNode tmp=null; int k=0; while(p!=null&amp;&amp;q!=null) { p.next=q.next; q.next=p; if(k==0) { head=q; }else{ tmp.next=q; } tmp=p; k++; p=p.next; if(p!=null){ q=p.next; }else{ q=null; } } return head; }} 第二十五题 1234567891011121314151617181920212223242526272829303132/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode currentNode = head; if (currentNode == null || k &lt; 0){ return head; } int count = 0; while (currentNode != null &amp;&amp; count &lt; k){ // find the k+1 node currentNode = currentNode.next; count++; } if (count == k){ // if k+1 node is found currentNode = reverseKGroup(currentNode, k); // reverse list with k+1 node as head while (count-- &gt; 0){ // reverse current k-group: ListNode temp = head.next; head.next = currentNode; currentNode = head; head = temp; } head = currentNode; } return head; }}","link":"/2018/08/18/blog12/"},{"title":"Leetcode刷题第十一天","text":"今天第一次做了LeetCode的周赛，半个小时才做完第一道题，太菜了后面第二题一直WA，结果做完之后看了uwi的解答，我的天，豁然开朗这次uwi也没进前三，可能是因为从最难的题开始做影响了一点速度总的来说LeetCode的竞赛题目其实挺简单的，但是我还是弱了附上今天AC的前两道题和uwi的解答 第888题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public int[] fairCandySwap(int[] A, int[] B) { int sum=0; int rsA=0; int rsB=0; int n=0; int rs[]=new int[2]; for(int i=0;i&lt;A.length;i++) { sum+=A[i]; rsA+=A[i]; } for(int i=0;i&lt;B.length;i++) { sum+=B[i]; rsB+=B[i]; } sum=sum/2; int flag=0; if(rsA&gt;rsB) { n=rsA-sum; for(int i=0;i&lt;A.length;i++) { for(int j=0;j&lt;B.length;j++) { if(A[i]-B[j]==n) { rs[0]=A[i]; rs[1]=B[j]; flag=1; break; } if(flag==1) { break; } } } }else { n=rsB-sum; for(int i=0;i&lt;B.length;i++) { for(int j=0;j&lt;A.length;j++) { if(B[i]-A[j]==n) { rs[0]=A[j]; rs[1]=B[i]; break; } } if(flag==1) { break; } } } return rs; }} 第890题1234567891011121314151617181920212223class Solution { public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) { List&lt;String&gt; list=new ArrayList&lt;&gt;(); outter: for(String s:words) { for(int i=0;i&lt;s.length();i++) { for(int j=i+1;j&lt;s.length();j++) { char ii=s.charAt(i); char ij=s.charAt(j); char pi=pattern.charAt(i); char pj=pattern.charAt(j); if(ii==ij&amp;&amp;pi!=pj) { continue outter; }else if(ii!=ij&amp;&amp;pi==pj) { continue outter; } } } list.add(s); } return list; }} 以下为uwi的代码第888题123456789101112131415class Solution { public int[] fairCandySwap(int[] A, int[] B) { int bal = 0; for(int v : A)bal -= v; for(int v : B)bal += v; for(int v : A){ for(int w : B){ if(w - v == bal/2){ return new int[]{v, w}; } } } return null; }} 第890题123456789101112131415161718192021222324252627class Solution { public List&lt;String&gt; findAndReplacePattern(String[] words, String pattern) { List&lt;String&gt; ret = new ArrayList&lt;&gt;(); outer: for(String w : words){ for(int i = 0;i &lt; w.length();i++){ for(int j = i+1;j &lt; w.length();j++){ char ii = w.charAt(i); char jj = w.charAt(j); char pi = pattern.charAt(i); char pj = pattern.charAt(j); if(ii == jj){ if(pi != pj){ continue outer; } }else{ if(pi == pj){ continue outer; } } } } ret.add(w); } return ret; }} 第889题12345678910111213141516171819202122232425262728class Solution { public TreeNode constructFromPrePost(int[] pre, int[] post) { return dfs(pre, post); } TreeNode dfs(int[] pre, int[] post) { if(pre.length == 0)return null; assert pre[0] == post[post.length-1]; TreeNode me = new TreeNode(pre[0]); if(pre.length &gt;= 2){ for(int i = 0;i &lt; post.length;i++){ if(post[i] == pre[1]){ TreeNode L = dfs(Arrays.copyOfRange(pre, 1, i+2), Arrays.copyOfRange(post, 0, i+1) ); TreeNode R = dfs(Arrays.copyOfRange(pre, i+2, pre.length), Arrays.copyOfRange(post, i+1, post.length-1) ); me.left = L; me.right = R; break; } } } return me; }} 第891题123456789101112131415161718192021class Solution { public int sumSubseqWidths(int[] a) { int mod = 1000000007; Arrays.sort(a); int n = a.length; // a[n-2]*1+a[n-1]*2 long s = 0; long num = 0; long ans = 0; for(int i = n-1;i &gt;= 1;i--){ s = s * 2 + a[i]; num = num * 2 + 1; s %= mod; num %= mod; ans += s - num * a[i-1]; ans %= mod; } if(ans &lt; 0)ans += mod; return (int)ans; }}","link":"/2018/08/19/blog13/"},{"title":"Leetcode刷题第十二天","text":"20号陪女朋友去医院弄牙齿然后回家，忙碌了一天，回家后准备在21号开始继续完善我的教务系统服务网站，吃过晚饭后手贱的我打开了IntelliJ，卧槽，我的项目居然不见了，回想自己在学校有一天删不用的文件，居然把有项目的那个文件夹删了，我真的醉了，当时直接看文件夹名感觉是没用的就删了。。。 这几天都没刷题，21号基本恢复了之前的样子，22号加入了我想好的新功能，23号学习linux部署然后改bug成功上线，哈哈哈，三天终于弄好了这个以后可以帮我解决很多类似评奖学金和收作业的网站，心里还是成就感满满的，包括之前7月弄了3天，前前后后大概做了一周吧，这里还要感谢一下13级邓振鹏学长，他的代码帮我解决了很大的问题。 今天继续开始刷LeetCode，收获了一个新的处理字符串的思路，以后还要多读别人的代码，收获真的很大。 第26题 123456789101112131415class Solution { public int removeDuplicates(int[] nums) { int n=0; for(int i=0;i&lt;nums.length-n;i++) { if(i&gt;0&amp;&amp;nums[i-1]==nums[i]) { for(int j=i-1;j&lt;nums.length-1;j++) { nums[j]=nums[j+1]; } i--; n++; } } return nums.length-n; }} 第27题 123456789101112class Solution { public int removeElement(int[] nums, int val) { int n=0; for(int i=0;i&lt;nums.length;i++) { if(nums[i]!=val){ nums[n]=nums[i]; n++; } } return n; }} 第28题 12345class Solution { public int strStr(String haystack, String needle) { return haystack.indexOf(needle); }} 第29题 12345678910class Solution { public int divide(int dividend, int divisor) { double a=(double)dividend; double b=(double)divisor; if(a/b&gt;Math.pow(2,31)-1||a/b&lt;Math.pow(-2,31)){ return (int) (Math.pow(2,31)-1); } return dividend/divisor; }} 第30题 123456789101112131415161718192021222324252627282930313233343536class Solution { public List&lt;Integer&gt; findSubstring(String s, String[] words) { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); if(s==null||&quot;&quot;.equals(s)||words.length==0) { return list; } Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0;i&lt;words.length;i++) { map.put(words[i], map.getOrDefault(words[i],0)+1); } int len=words[0].length(); int num=words.length; for(int i=0;i&lt;s.length()-num*len+1;i++) { int j=0; Map&lt;String,Integer&gt; seen=new HashMap&lt;&gt;(); while(j&lt;num) { int begin=i+j*len; int end=i+(j+1)*len; String temp=s.substring(begin, end); if(map.containsKey(temp)) { seen.put(temp, seen.getOrDefault(temp, 0)+1); if(map.get(temp)&lt;seen.get(temp)) { break; } }else { break; } j++; } if(j==num) { list.add(i); } } return list; }}","link":"/2018/08/24/blog14/"},{"title":"Leetcode刷题第十三天","text":"咸鱼的一天 第31题 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public void nextPermutation(int[] nums) { int flag=0; int temp; for(int i=nums.length-1;i&gt;0;i--) { if(nums[i]&gt;nums[i-1]) { int min=nums[i-1]; int index=nums.length-1; for(int j=i+1;j&lt;nums.length;j++) { if(nums[j]&lt;=min) { index=j-1; break; } } temp=nums[i-1]; nums[i-1]=nums[index]; nums[index]=temp; int k=i; int n=nums.length-1; while(k&lt;n) { temp=nums[k]; nums[k]=nums[n]; nums[n]=temp; k++; n--; } flag=1; break; } } if(flag==0) { for(int k=0;k&lt;nums.length/2;k++) { temp=nums[k]; nums[k]=nums[nums.length-1-k]; nums[nums.length-1-k]=temp; } } }} 第32题 12345678910111213141516171819202122232425262728class Solution { public int longestValidParentheses(String s) { if(s==null||s.length()==0||s.equals(&quot;&quot;)) { return 0; } int st=0; int max=0; Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); for(int i=0;i&lt;s.length();i++) { if(s.charAt(i)=='(') { stack.push(i); }else { if(stack.isEmpty()) { st=i+1; continue; }else { int n=stack.pop(); if(stack.isEmpty()) { max=max&gt;i-st+1?max:i-st+1; }else { max=max&gt;i-stack.lastElement()?max:i-stack.lastElement(); } } } } return max; }}","link":"/2018/08/25/blog15/"},{"title":"Leetcode刷题第十四天","text":"今天又起来晚了，然后就做了比赛的两道水题 第33题 123456789101112131415161718192021222324252627class Solution { public int search(int[] nums, int target) { if(nums.length==0){ return -1; } int st=0; int end=nums.length-1; while(st&lt;=end) { int mid=(st+end)/2; if(nums[mid]==target)return mid; if(nums[st]&lt;=nums[mid]) { if(nums[st]&lt;=target&amp;&amp;target&lt;=nums[mid]) { end=mid-1; }else { st=mid+1; } }else { if(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[end]) { st=mid+1; }else { end = mid-1; } } } return -1; }} 第34题 12345678910111213141516171819202122232425262728293031323334353637383940class Solution { public int[] searchRange(int[] nums, int target) { int [] pos= {-1,-1}; if(nums.length==0){ return pos; } int st=0; int end=nums.length-1; while(st&lt;=end) { int mid=(st+end)/2; if(nums[mid]==target) { int temp=mid; while(0&lt;=mid) { if(nums[mid]==target) { pos[0]=mid; mid--; }else{ break; } } mid=temp; while(mid&lt;nums.length) { if(nums[mid]==target) { pos[1]=mid; mid++; }else{ break; } } return pos; } if(nums[mid]&lt;target) { st=mid+1; }else { end=mid-1; } } return pos; }} 第892题 1234567891011121314151617181920class Solution { public int surfaceArea(int[][] grid) { int n = grid.length, m = grid[0].length; int all = 0; int nei = 0; for(int i = 0;i &lt; n;i++){ for(int j = 0;j &lt; m;j++){ all += grid[i][j]; if(j+1 &lt; m){ nei += Math.min(grid[i][j], grid[i][j+1]); } if(i+1 &lt; n){ nei += Math.min(grid[i][j], grid[i+1][j]); } if(grid[i][j] &gt; 0)nei += grid[i][j]-1; } } return all*6-nei*2; }} 第893题 1234567891011121314151617181920212223class Solution { public int numSpecialEquivGroups(String[] A) { Set&lt;String&gt; set=new HashSet&lt;&gt;(); char[] odd=null; char[] even=null; for(String s:A) { odd=new char[100]; even =new char[100]; int k=0;int n=0; for(int i=0;i&lt;s.length();i++) { if(i%2==0) { even[k++]=s.charAt(i); }else { odd[n++]=s.charAt(i); } } Arrays.sort(even); Arrays.sort(odd); set.add(new String(even)+new String(odd)); } return set.size(); }}","link":"/2018/08/26/blog16/"},{"title":"Leetcode刷题第十五天","text":"今天做了八皇后的升级版填数独，又一次巩固了回溯法。 第35题 12345678910111213141516171819class Solution { public int searchInsert(int[] nums, int target) { int j=0; int i=0; if(target&lt;nums[0]){ return 0; } for(i=0;i&lt;nums.length;i++) { if(nums[i]==target) { return i; } j=i+1; if(j&lt;nums.length&amp;&amp;nums[j]&gt;target&amp;&amp;nums[i]&lt;=target) { return j; } } return i; }} 第36题 1234567891011121314151617181920212223242526272829303132333435class Solution { public boolean isValidSudoku(char[][] board) { for (int i = 0; i &lt; 9; i++) { Set&lt;Character&gt; set1 = new HashSet&lt;&gt;(); Set&lt;Character&gt; set2 = new HashSet&lt;&gt;(); for (int j = 0; j &lt; 9; j++) { if (board[i][j] != '.') { if (!set1.add(board[i][j])) { return false; } } if (board[j][i] != '.') { if (!set2.add(board[j][i])) { return false; } } } } for(int m=0;m&lt;3;m++) { for (int i = 0; i &lt; 3; i++) { Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for (int j = 3 * i; j &lt; 3 * (i + 1); j++) { for (int k = m * 3; k &lt; (m + 1) * 3; k++) { if (board[j][k] != '.') { if (!set.add(board[j][k])) { return false; } } } } } } return true; }} 第37题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution { private char[][] board; private boolean row[][]; private boolean col[][]; private boolean subCube[][]; public void solveSudoku(char[][] board) { this.board=board; row=new boolean[9][9]; col=new boolean[9][9]; subCube=new boolean[9][9]; for(int i=0;i&lt;9;i++) { for(int j=0;j&lt;9;j++) { if(board[i][j]!='.') { int var=board[i][j]-'0'; row[i][var-1]=true; col[j][var-1]=true; subCube[(i/3)*3+j/3][var-1]=true; } } } fun(0,0); } public boolean fun(int i,int j) { if(i==9) { return true; } int x=i; int y=j; if(y==8) { y=0; x++; }else { y++; } if(board[i][j]=='.') { for(int k=1;k&lt;=9;k++) { if(!row[i][k-1]&amp;&amp;!col[j][k-1]&amp;&amp;!subCube[(i/3)*3+j/3][k-1]) { row[i][k-1]=true; col[j][k-1]=true; subCube[(i/3)*3+j/3][k-1]=true; if(fun(x,y)) { board[i][j]=(char) (k+'0'); return true; } row[i][k-1]=false; col[j][k-1]=false; subCube[(i/3)*3+j/3][k-1]=false; } } }else { return fun(x,y); } return false; }}","link":"/2018/08/27/blog17/"},{"title":"Leetcode刷题第十六天","text":"今天因为美赛奖金的事情来学校，本来说必须参加这次国赛才会发奖金，但是现在貌似又不是强制性的了。。。可能是因为这次参加的人比较多吧。回想起去年自己一个人从两江跑过来参加培训，大一的人可能一共就只有5个吧，今年过来培训的大一的就占了整个培训人数的一半，真是莫大的差别呀，希望学校越来越好吧，这届大一的学弟学妹们可能比我还厉害吧。经过了校赛，国赛，美赛这一轮游下来，收获挺多的我也该退役了，哈哈哈，程序设计大赛等着我哦。 第38题 123456789101112131415161718192021222324class Solution { public String countAndSay(int n) { if(n==1) return 1+&quot;&quot;; String pre=&quot;11&quot;; StringBuffer sb=new StringBuffer(); int count=1; while(n&gt;2) { for(int i=1;i&lt;pre.length();i++) { if(pre.charAt(i)==pre.charAt(i-1)) { count++; }else { sb.append(count).append(pre.charAt(i-1)); count=1; } } sb.append(count).append(pre.charAt(pre.length()-1)); pre=sb.toString(); sb.replace(0, sb.length(), &quot;&quot;); count=1; n--; } return pre; }} 第39题 1234567891011121314151617181920212223242526272829class Solution { private int[] candidates; private int target; private List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { this.candidates=candidates; this.target=target; fun(0,new ArrayList&lt;Integer&gt;()); return list.stream().distinct().collect(Collectors.toList()); } public void fun(int n,List&lt;Integer&gt; t) { if(n==target) { List&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); for(Integer i:t) { temp.add(i); } Collections.sort(temp); list.add(temp); return; } if(n&gt;target) return; for(int i=0;i&lt;candidates.length;i++) { Integer a=candidates[i]; t.add(a); fun(n+a,t); t.remove(a); } }}","link":"/2018/08/28/blog18/"},{"title":"Leetcode刷题第十七天","text":"偷了两天懒，一天陪女朋友继续去看牙齿，第二天又和女朋友出去玩了一天，深感钱不够用，开始想方设法赚钱了，质问自己为什么大二不知道早点开始赚钱。 第40题 1234567891011121314151617181920212223242526272829class Solution { private int[] candidates; private int target; private List&lt;List&lt;Integer&gt;&gt; list=new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { this.candidates=candidates; this.target=target; fun(0,new ArrayList&lt;Integer&gt;(),0); return list.stream().distinct().collect(Collectors.toList()); } public void fun(int n,List&lt;Integer&gt; t,int index) { if(n==target) { List&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); for(Integer i:t) { temp.add(i); } Collections.sort(temp); list.add(temp); return; } if(n&gt;target||index==candidates.length) return; for(int i=index;i&lt;candidates.length;i++) { Integer a=candidates[i]; t.add(a); fun(n+a,t,i+1); t.remove(a); } }} 第41题 123456789101112131415class Solution { public int firstMissingPositive(int[] nums) { Arrays.sort(nums); int idx=1; for(int i=0;i&lt;nums.length;i++) { if(nums[i]-idx&gt;0) { return idx; } if(nums[i]-idx==0) { idx++; } } return idx; }} 第42题 12345678910111213141516171819202122232425262728293031323334353637class Solution { public int trap(int[] height) { if(height.length&lt;=2){ return 0; } int top=height[0]; int index=0; for(int i=0;i&lt;height.length;i++) { if(top&lt;height[i]) { top=height[i]; index=i; } } int a=0; int rs=0; for(int j=0;j&lt;index;j++) { if(height[j]&gt;a) { a=height[j]; continue; } if(height[j]&lt;a) { rs+=a-height[j]; } } a=0; for(int j=height.length-1;j&gt;index;j--) { if(height[j]&gt;a) { a=height[j]; continue; } if(height[j]&lt;a) { rs+=a-height[j]; } } return rs; }}","link":"/2018/08/31/blog19/"},{"title":"Leetcode刷题第十八天","text":"啊，已经9月了，又是咸鱼的一天。。。火盆烧烤还没吃到 第43题 1234567891011121314151617181920212223242526272829class Solution { public String multiply(String num1, String num2) { int len1=num1.length(); int len2=num2.length(); int n=len1+len2; int[] arr=new int[n]; for(int i=len1-1;i&gt;=0;i--) { for(int j=len2-1;j&gt;=0;j--) { arr[i+j+1]+=(num1.charAt(i)-'0')*(num2.charAt(j)-'0'); } } int carry=0; for(int i=n-1;i&gt;=0;i--) { arr[i]=arr[i]+carry; carry=arr[i]/10; arr[i]=arr[i]%10; } int flag=0; String rs=&quot;&quot;; for(int i=0;i&lt;n;i++) { if(flag==0&amp;&amp;arr[i]==0) { continue; } flag=1; rs+=arr[i]; } return rs.equals(&quot;&quot;)?&quot;0&quot;:rs; }} 第44题 1234567891011121314151617181920212223242526class Solution { public boolean isMatch(String s, String p) { int countXing=0; for(char c:p.toCharArray()) { if(c=='*'||c=='?') { countXing++; } } if(p.length()-countXing&gt;s.length())return false; boolean[][] dp=new boolean[p.length()+1][s.length()+1]; dp[0][0]=true; for(int i=1;i&lt;=p.length();i++) { char char_p=p.charAt(i-1); dp[i][0]=dp[i-1][0]&amp;&amp;char_p=='*'; for(int j=1;j&lt;=s.length();j++) { char char_s=s.charAt(j-1); if(char_p=='*') { dp[i][j]=dp[i][j-1]||dp[i-1][j]; }else { dp[i][j]=dp[i-1][j-1]&amp;&amp;(char_p=='?'||char_s==char_p); } } } return dp[p.length()][s.length()]; }} 第45题 12345678910111213141516171819202122232425262728class Solution { public int jump(int[] nums) { if(nums.length&lt;=1) { return 0; } int step=0; int index=0; int max=0; int temp=0; while(index&lt;nums.length-1) { max=0; temp=0; for(int i=1;i&lt;=nums[index];i++) { if(index+i&gt;=nums.length-1) { temp=i; break; } if(i+nums[index+i]&gt;=max) { max=nums[index+i]+i; temp=i; } } index+=temp; step++; } return step; }}","link":"/2018/09/01/blog20/"},{"title":"Leetcode刷题第十九天","text":"今天打了比赛，LeetCode题目能够说清楚一点吗？uwi，18分钟做完所有题哈哈哈。。。 第896题12345678910111213141516171819202122class Solution { public boolean isMonotonic(int[] A) { int flag=0; for(int i=1;i&lt;A.length;i++) { if(A[i]&gt;A[i-1]) { flag=1; } } if(flag==0) { return true; } for(int i=1;i&lt;A.length;i++) { if(A[i]&lt;A[i-1]) { flag=0; } } if(flag==1) { return true; } return false; }} 第897题1234567891011121314151617181920212223242526272829303132/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); public TreeNode increasingBST(TreeNode root) { fun(root); TreeNode rs=new TreeNode(list.get(0)); TreeNode t=rs; for(int i=1;i&lt;list.size();i++) { TreeNode c=new TreeNode(list.get(i)); t.right=c; t=c; } return rs; } public void fun(TreeNode n) { if(n==null) { return; } fun(n.left); list.add(n.val); fun(n.right); }} 第899题123456789101112131415161718class Solution { public String orderlyQueue(String S, int K) { String rs=S; if(K&gt;1) { char[] arr=S.toCharArray(); Arrays.sort(arr); return new String(arr); }else { for(int i=0;i&lt;S.length();i++) { String T=S.substring(i)+S.substring(0,i); if(T.compareTo(rs)&lt;0) { rs=T; } } } return rs; }} #以下为uwi的代码 第896题1234567891011121314151617181920class Solution { public boolean isMonotonic(int[] a) { int n = a.length; { boolean ok = true; for(int i = 0;i &lt; n-1;i++){ if(a[i] &gt; a[i+1])ok = false; } if(ok)return true; } { boolean ok = true; for(int i = 0;i &lt; n-1;i++){ if(a[i] &lt; a[i+1])ok = false; } if(ok)return true; } return false; }} 第897题1234567891011121314151617class Solution { public TreeNode increasingBST(TreeNode root) { TreeNode dummy = new TreeNode(1); dfs(root, dummy); return dummy.right; }TreeNode dfs(TreeNode root, TreeNode p){ if(root == null)return p; p = dfs(root.left, p); TreeNode c = new TreeNode(root.val); p.right = c; p = c; p = dfs(root.right, p); return p; }} 第898题12345678910111213141516171819202122232425262728293031323334353637class Solution {public int subarrayBitwiseORs(int[] a) { int n = a.length; int[] next = new int[31]; Arrays.fill(next, n); int[] u = new int[33*n]; int p = 0; long[] t = new long[31]; for(int i = n-1;i &gt;= 0;i--){ for(int j = 0;j &lt; 31;j++){ if(a[i]&lt;&lt;~j&lt;0){ next[j] = i; } t[j] = (long)next[j]&lt;&lt;32|j; } Arrays.sort(t); u[p++] = a[i]; int b = 0; for(int j = 0;j &lt; 31;){ int k = j; if(t[j]&gt;&gt;&gt;32 == n)break; while(k &lt; 31 &amp;&amp; t[k]&gt;&gt;&gt;32==t[j]&gt;&gt;&gt;32){ b |= 1&lt;&lt;(int)t[k]; k++; } u[p++] = b; j = k; } } Arrays.sort(u, 0, p); int ct = 0; for(int i = 0;i &lt; p;i++){ if(i == 0 || u[i-1] != u[i])ct++; } return ct; }} 第899题12345678910111213141516171819class Solution { public String orderlyQueue(String S, int K) { int n = S.length(); if(K &gt;= 2){ char[] s = S.toCharArray(); Arrays.sort(s); return new String(s); }else{ String ret = S; for(int i = 0;i &lt; n;i++){ String T = S.substring(i) + S.substring(0, i); if(T.compareTo(ret) &lt; 0){ ret = T; } } return ret; } }}","link":"/2018/09/02/blog21/"},{"title":"Leetcode刷题第二十天","text":"二十天了哈哈哈。。。昨天和今天又出去玩了，寝室的同学们来了很多了 第46题 1234567891011121314151617181920212223242526class Solution { private List&lt;List&lt;Integer&gt;&gt; rs =new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { boolean[] can=new boolean[nums.length]; fun(nums,can,0,new ArrayList&lt;Integer&gt;()); return rs; } public void fun(int[] nums,boolean[] can,int idx,List list) { if(idx==nums.length) { List&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); temp.addAll(list); rs.add(temp); return; } for(int i=0;i&lt;nums.length;i++) { if(can[i]==false) { can[i]=true; Integer t=nums[i]; list.add(t); fun(nums,can,idx+1,list); list.remove(t); can[i]=false; } } }} 第47题 1234567891011121314151617181920212223242526class Solution { private List&lt;List&lt;Integer&gt;&gt; rs =new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums){ boolean[] can=new boolean[nums.length]; fun(nums,can,0,new ArrayList&lt;Integer&gt;()); return rs.stream().distinct().collect(Collectors.toList()); } public void fun(int[] nums,boolean[] can,int idx,List list) { if(idx==nums.length) { List&lt;Integer&gt; temp=new ArrayList&lt;&gt;(); temp.addAll(list); rs.add(temp); return; } for(int i=0;i&lt;nums.length;i++) { if(can[i]==false) { can[i]=true; Integer t=nums[i]; list.add(t); fun(nums,can,idx+1,list); list.remove(list.size()-1); can[i]=false; } } }} 第48题 1234567891011121314151617181920class Solution { public void rotate(int[][] matrix) { int row_len=matrix.length; int col_len=matrix[0].length; for(int i=0;i&lt;row_len;i++) { for(int j=0;j&lt;col_len/2;j++) { int temp=matrix[i][j]; matrix[i][j]=matrix[i][col_len-1-j]; matrix[i][col_len-1-j]=temp; } } for(int i=0;i&lt;row_len;i++) { for(int j=0;j&lt;col_len-i-1;j++) { int temp=matrix[i][j]; matrix[i][j]=matrix[row_len-1-j][col_len-1-i]; matrix[row_len-1-j][col_len-1-i]=temp; } } }}","link":"/2018/09/03/blog22/"},{"title":"Leetcode刷题第二十一天","text":"终于刷到了自己的第50道题，最近可能会很忙。。。 第49题 1234567891011121314151617181920212223class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { Map&lt;String,List&lt;String&gt;&gt; map=new HashMap&lt;&gt;(); for(int i=0;i&lt;strs.length;i++) { char[] arr=strs[i].toCharArray(); Arrays.sort(arr); if(map.get(new String(arr))==null) { List&lt;String&gt; list =new ArrayList&lt;&gt;(); list.add(strs[i]); map.put(new String(arr), list); }else { List&lt;String&gt; list=map.get(new String(arr)); list.add(strs[i]); map.put(new String(arr), list); } } List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;(); for(List&lt;String&gt; t:map.values()) { res.add(t); } return res; }} 第50题 这道题的解法有一些需要注意的地方，按照常规的做法会超时，但是仔细一想就会发现有可以优化的地方，第一次写题解就给我的第50题吧！最简单粗暴的解法（可是会超时） 12345678910class Solution { public double myPow(double x, int n) { if(n == 0) return 1; if(n&lt;0) { t=Math.abs(t); x=1.0/x; } return myPow(x, n-1) * x; }} 修改后的算法，时间复杂度真的下降为 O(logn)了吗？非也，由于递归的特性——无法记录下中间结果， myPow(x, n / 2) 被计算了两次，因此复杂度为 O(log(2^n)) = O(n)，也会超时。我们最好用一个值两记录下中间变量，充分利用好中间结果，克服这种毛病。 123456789101112class Solution { public double myPow(double x, int n) { if(n == 0) return 1; if(n == 1) return x; if(n&lt;0) { t=Math.abs(t); x=1.0/x; } if(n%2==0) return myPow(x, n / 2) * myPow(x, n / 2); return myPow(x, n / 2) * myPow(x, n / 2)*x; }} 最终解法，本题的难点主要是在边界条件：如果 n &lt; 0，是不是 n = -n， x = 1 / x ，再进行递归就能解决了呢？如果 n = Integer.MIN_VALUE，n = -n 会出现溢出，怎么办呢？我们可以先将 n / 2 赋值给 t，再将 t = -t，就不会出现溢出问题。 1234567891011121314class Solution { public double myPow(double x, int n) { if(n==0)return 1; if(n==1)return x; int t=n/2; if(n&lt;0) { t=Math.abs(t); x=1.0/x; } double res=myPow(x,t); if(n%2==0)return res*res; return res*res*x; }}","link":"/2018/09/04/blog23/"},{"title":"Leetcode刷题第二十二天","text":"创业失败的一天，辛苦的一天，好累啊。。。。。。。。 第51题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { private int total=0; private List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) { fun(0,n,new ArrayList&lt;String&gt;()); System.out.println(total); return res; } public void fun(int x,int n,List&lt;String&gt; list) { if(x==n) { List&lt;String&gt; t=new ArrayList&lt;&gt;(); t.addAll(list); res.add(t); total++; return; } int flag=0; for(int i=0;i&lt;n;i++) { flag=0; for(int j=x-1;j&gt;=0;j--) { String row=list.get(j); if(row.charAt(i)=='Q') { flag=1; break; } int col_idx=x-j; if(i-col_idx&gt;=0) { if(row.charAt(i-col_idx)=='Q') { flag=1; break; } } if(i+col_idx&lt;n) { if(row.charAt(i+col_idx)=='Q') { flag=1; break; } } } if(flag==0) { char[] crr=new char[n]; for(int k=0;k&lt;n;k++) { crr[k]='.'; } crr[i]='Q'; list.add(new String(crr)); fun(x+1,n,list); list.remove(list.size()-1); } } }} 第52题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution { private int total=0; public int totalNQueens(int n) { fun(0,n,new ArrayList&lt;String&gt;()); System.out.println(total); return total; } public void fun(int x,int n,List&lt;String&gt; list) { if(x==n) { total++; return; } int flag=0; for(int i=0;i&lt;n;i++) { flag=0; for(int j=x-1;j&gt;=0;j--) { String row=list.get(j); if(row.charAt(i)=='Q') { flag=1; break; } int col_idx=x-j; if(i-col_idx&gt;=0) { if(row.charAt(i-col_idx)=='Q') { flag=1; break; } } if(i+col_idx&lt;n) { if(row.charAt(i+col_idx)=='Q') { flag=1; break; } } } if(flag==0) { char[] crr=new char[n]; for(int k=0;k&lt;n;k++) { crr[k]='.'; } crr[i]='Q'; list.add(new String(crr)); fun(x+1,n,list); list.remove(list.size()-1); } } }} 第53题 最直接想到的暴力解法，结局当然是超时 123456789101112131415161718class Solution { private int max = Integer.MIN_VALUE; public int maxSubArray(int[] nums) { int sum; for (int i = 0; i &lt; nums.length; i++) { for (int j = i; j &lt; nums.length; j++) { sum = 0; for (int k = i; k &lt;= j; k++) { sum += nums[k]; } if (sum &gt; max) { max = sum; } } } return max; }} 改进后的算法，通过了但是排名很低，耗时118ms 123456789101112131415class Solution { private int max = Integer.MIN_VALUE; public int maxSubArray(int[] nums) { int sum; for (int i = 0; i &lt; nums.length; i++) { sum = 0; for (int j = i; j &lt; nums.length; j++) { sum += nums[j]; if (sum &gt; max) max = sum; } } return max; }} 继续改进，搜索资料后知道使用扫描法，好像是编程珠玑里面的一个经典例子，这里抄过来简单介绍一下扫描法:当我们加上一个正数时，和会增加；当我们加上一个负数时，和会减少。如果当前得到的和是个负数，那么这个和在接下来的累加中应该抛弃并重新清零，不然的话这个负数将会减少接下来的和。 123456789101112131415161718192021222324252627282930313233据说这道题是《编程珠机》里面的题目，叫做扫描法，速度最快，扫描一次就求出结果，复杂度是O（n）。书中说，这个算法是一个统计学家提出的。这个算法如此精炼简单，而且复杂度只有线性。但是我想，能想出来却非常困难，而且证明也不简单。在这里，我斗胆写出自己证明的想法：关于这道题的证明，我的思路是去证明这样的扫描法包含了所有n^2种情况，即所有未显示列出的子数组都可以在本题的扫描过程中被抛弃。1 首先，假设算法扫描到某个地方时，始终未出现加和小于等于0的情况。我们可以把所有子数组（实际上为当前扫描过的元素所组成的子数组）列为三种：1.1 以开头元素为开头，结尾为任一的子数组1.2 以结尾元素为结尾，开头为任一的子数组1.3 开头和结尾都不等于当前开头结尾的所有子数组1.1由于遍历过程中已经扫描，所以算法已经考虑了。1.2确实没考虑，但我们随便找到1.2中的某一个数组，可知，从开头元素到这个1.2中的数组的加和大于0（因为如果小于0就说明扫描过程中遇到小于0的情况，不包括在大前提1之内），那么这个和一定小于从开头到这个1.2数组结尾的和。故此种情况可舍弃1.3 可以以1.2同样的方法证明，因为我们的结尾已经列举了所有的情况，那么每一种情况和1.2是相同的，故也可以舍弃。2 如果当前加和出现小于等于0的情况，且是第一次出现，可知前面所有的情况加和都不为0一个很直观的结论是，如果子段和小于0，我们可以抛弃，但问题是是不是他的所有以此子段结尾为结尾而开头任意的子段也需要抛弃呢？答案是肯定的。因为以此子段开头为开头而结尾任意的子段加和都大于0（情况2的前提），所以这些子段的和是小于当前子段的，也就是小于0的，对于后面也是需要抛弃的。也就是说，所有以之前的所有元素为开头而以当前结尾之后元素为结尾的数组都可以抛弃了。而对于后面抛弃后的数组，则可以同样递归地用1 2两个大情况进行分析，于是得证。 改进后的算法，耗时16ms，排名提升很多 123456789101112class Solution { public int maxSubArray(int[] nums) { int current=nums[0]; int sum=nums[0]; for(int i=1;i&lt;nums.length;i++){ if(current&lt;0)current=nums[i]; else current+=nums[i]; if(sum&lt;current)sum=current; } return sum; }} 根据题目的要求，思考了一下分治法，这里也写出来，但是这道题用分治法貌似用时更长，理论上使用分治法的复杂度是O(nlogn)使用分治法，耗时265ms,貌似比第二种算法还长呀。。。但是巩固了一下分治法 12345678910111213141516171819202122232425262728293031class Solution { public int maxSubArray(int[] nums) { return divide(0,nums.length-1,nums); } public int divide(int left,int right,int[] nums) { if(left==right) { return nums[left]; } int center=(left+right)/2; int leftMaxVal=divide(left,center,nums); int rightMaxVal=divide(center+1,right,nums); int leftVal=nums[center]; int leftBorderVal=nums[center]; for(int i=center-1;i&gt;=0;i--) { leftVal+=nums[i]; if(leftVal&gt;leftBorderVal) { leftBorderVal=leftVal; } } int rightVal=nums[center+1]; int rightBorderVal=nums[center+1]; for(int i=center+2;i&lt;nums.length;i++) { rightVal+=nums[i]; if(rightVal&gt;rightBorderVal) { rightBorderVal=rightVal; } } int BorderVal=rightBorderVal+leftBorderVal; return Math.max(BorderVal, Math.max(leftMaxVal, rightMaxVal)); }}","link":"/2018/09/05/blog24/"},{"title":"Leetcode刷题第二十三天","text":"又是两天没刷题，9月6号开始统计这学年的奖学金，心想自己做的网站终于可以上场了，结果把最新的版本部署上服务器后，无法正常访问了。。。然后本地测试是可以访问的，弄了一个上午还是没找到问题所在，结果后面心想去教务系统官网看看发现教务系统瘫痪了。。。本地网速快可能才练的上去吧，服务器那小水管网速怪说不得上不去。。。心力憔悴地感叹学校人真TM多，教务系统真TM垃圾，是不是根本没考虑1000人左右的并发啊。。。真的醉了，然后下午4点左右终于正常了。。。然后就是各种统计绩点加分什么的，昨天下午5点才弄完。。。汗颜，第一次体会到这些paper work真TM累。。。昨天最幸福的事情应该就是和媳妇儿去吃了心念已久的火盆烧烤吧，真的太TM好吃了，以后都不想去吃那些韩国烤肉了，哈哈哈，回来的时候还发现学校门口终于开了一家LAWSON便利店，当然要进去逛啊，买了一瓶黄瓜味的汽水，一个冰皮月饼，真的吼吼吃哦。在下雨天吃烤肉，吃饱了撑着伞和媳妇儿走在学校的林荫道，世界上真的没有比这更幸福快乐的事情了吧！回到寝室还吃了胡文带来的兔子，然后看电影，劳累了两天这样的结尾真棒！今天媳妇儿告诉我她昨天开心的都睡不着，哈哈哈，真是个傻猪猪~ 第54题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); int row_len=matrix.length; if(row_len==0 || matrix==null ) { return res; } int col_len=matrix[0].length; boolean[][] status=new boolean[row_len][col_len]; int i=0,j=0; int x=0,y=0; while(i&lt;row_len-x&amp;&amp;j&lt;col_len-y&amp;&amp;j&gt;=y&amp;&amp;i&gt;=x&amp;&amp;status[i][j]==false) { while(j&lt;col_len-y &amp;&amp; status[i][j]==false) { status[i][j]=true; res.add(matrix[i][j]); j++; } j--; i++; while(i&lt;row_len-x &amp;&amp; status[i][j]==false) { status[i][j]=true; res.add(matrix[i][j]); i++; } i--; j--; while(j&gt;=y &amp;&amp; status[i][j]==false) { status[i][j]=true; res.add(matrix[i][j]); j--; } j++; i--; y++; x++; while(i&gt;=x &amp;&amp; status[i][j]==false) { status[i][j]=true; res.add(matrix[i][j]); i--; } i++; j++; } return res; }} 第55题 1234567891011121314151617181920212223242526272829class Solution { public boolean canJump(int[] nums) { int n=nums.length-1; return fun(0,n,nums); } public boolean fun(int idx,int n,int[] nums) { if(idx==n) { return true; } int max=Integer.MIN_VALUE; int step=0; int flag=0; for(int i=1;i&lt;=nums[idx];i++) { flag=1; if(idx+i&gt;=n) { return true; } int temp=nums[idx+i]+i; if(temp&gt;max) { max=temp; step=i; } } if(flag==1&amp;&amp;fun(idx+step,n,nums)) { return true; } return false; }} 第56题 123456789101112131415161718192021222324252627282930313233/*** Definition for an interval.* public class Interval {* int start;* int end;* Interval() { start = 0; end = 0; }* Interval(int s, int e) { start = s; end = e; }* }*/class Solution { public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) { if(intervals==null || intervals.size()==0)return intervals; Collections.sort(intervals, new Comparator&lt;Interval&gt;() { @Override public int compare(Interval o1, Interval o2) { return o1.start-o2.start; } }); List&lt;Interval&gt; res=new ArrayList&lt;&gt;(); Interval inter=intervals.get(0); for(int i=1;i&lt;intervals.size();i++) { if(inter.end&gt;=intervals.get(i).start) { inter.end=Math.max(inter.end,intervals.get(i).end); } else { res.add(inter); inter=intervals.get(i); } } res.add(inter); return res; }}","link":"/2018/09/08/blog25/"},{"title":"Leetcode刷题第二十四天","text":"又是一个周末contest，今天leetcode服务器居然出问题了，晚开了15分钟，害的我以为只有自己账户出问题了，注册了一个新账户还是不行才知道是服务器出问题了。这次的题目是两个medium和两个hard，相对来说比较难，自己卡在一个地方很久结果在比赛结束的那一刻通过了，崩溃。。。 第900题123456789101112131415161718192021222324class RLEIterator { private int[] A; public RLEIterator(int[] A) { this.A=A; } public int next(int n) { int sum=0; for(int i=0;i&lt;A.length-1;i=i+2) { sum+=A[i]; if(sum&gt;=n) { A[i]=sum-n; return A[i+1]; }else { A[i]=0; } } return -1; }}/*** Your RLEIterator object will be instantiated and called as such:* RLEIterator obj = new RLEIterator(A);* int param_1 = obj.next(n);*/ 第901题1234567891011121314151617181920212223242526272829303132333435363738394041class StockSpanner { int[] A=new int[100000]; int[] B=new int[100000]; int idx=0; public StockSpanner() {} public int next(int price) { if(idx==0) { A[idx]=price; B[idx]=1; idx++; return 1; } int rs=1; int n=idx-1; if(A[n]&lt;price) { rs+=B[n]; n-=B[n]; } while(n&gt;=0) { if(A[n]&lt;price) { rs+=B[n]; n-=B[n]; } else if(A[n]==price){ rs+=B[n]; break; }else { break; } } A[idx]=price; B[idx]=rs; idx++; return rs; }}/*** Your StockSpanner object will be instantiated and called as such:* StockSpanner obj = new StockSpanner();* int param_1 = obj.next(price);*/ 以下为uwi的代码第900题123456789101112131415161718192021222324252627282930313233343536class RLEIterator { int[] a; int p = 0; public RLEIterator(int[] A) { a = A; p = 0; } public int next(int n) { if(p &gt;= a.length)return -1; n--; int ret = -1; while(n &gt; 0){ if(p &gt;= a.length)return -1; int ex = Math.min(a[p], n); n -= ex; a[p] -= ex; if(a[p] &gt; 0){ break; }else{ p += 2; } } while(p &lt; a.length &amp;&amp; a[p] == 0)p += 2; if(p &lt; a.length)ret = a[p+1]; n = 1; while(n &gt; 0){ if(p &gt;= a.length)return -1; int ex = Math.min(a[p], n); n -= ex; a[p] -= ex; if(n == 0)break; p += 2; } return ret; }} 第901题12345678910111213141516171819202122class StockSpanner { int[] stack; int[] value; int sp; int gen = 0; public StockSpanner() { stack = new int[11000]; value = new int[11000]; sp = 0; gen = 0; } public int next(int price) { while(sp &gt; 0 &amp;&amp; value[sp-1] &lt;= price){ sp--; } int ret = gen - (sp == 0 ? -1 : stack[sp-1]); stack[sp] = gen++; value[sp] = price; sp++; return ret; }} 第902题1234567891011121314151617181920212223242526class Solution { public int atMostNGivenDigitSet(String[] D, int N) { int mask = 0; for(String s : D){ mask ^= 1&lt;&lt;s.charAt(0)-'0'; } char[] s = Integer.toString(N+1).toCharArray(); long dp = 0; int e = 1; for(int i = 0;i &lt; s.length;i++){ dp *= Integer.bitCount(mask); for(int j = 1;j &lt; s[i]-'0';j++){ if(mask&lt;&lt;~j&lt;0){ dp+=e; } } if(i &gt; 0){ dp += Integer.bitCount(mask); } if(mask&lt;&lt;~(s[i]-'0')&gt;=0){ e = 0; } } return (int)dp; }} 第903题123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public int numPermsDISequence(String S) { int n = S.length(); int[] a = new int[n+1]; int p = 0; int len = 0; for(int i = 0;i &lt; n;i++){ if(S.charAt(i) == 'D'){ len++; }else{ a[p++] = len+1; len = 0; } } a[p++] = len+1; int mod = 1000000007; long[][] C = new long[400 + 1][400 + 1]; for (int i = 0; i &lt;= 400; i++) { C[i][0] = 1; for (int j = 1; j &lt;= i; j++) { C[i][j] = C[i - 1][j - 1] + C[i - 1][j]; if (C[i][j] &gt;= mod) C[i][j] -= mod; } } a = Arrays.copyOf(a, p); long[] dp = new long[p+1]; dp[0] = 1; int all = 0; for(int i = 1;i &lt;= p;i++){ all += a[i-1]; int s = 0; for(int j = i-1, sgn = 1;j &gt;= 0;j--, sgn = -sgn){ s += a[j]; dp[i] += dp[j] * C[all][s] * sgn; dp[i] %= mod; } if(dp[i] &lt; 0)dp[i] += mod; } return (int)dp[p]; }}","link":"/2018/09/09/blog26/"},{"title":"Leetcode刷题第二十五天","text":"发现自己真的很缺乏逻辑性还不喜欢打草稿理思路，明明是个菜鸡还觉得自己很厉害。。。 第57题 12345678910111213141516171819202122232425262728293031323334353637/*** Definition for an interval.* public class Interval {* int start;* int end;* Interval() { start = 0; end = 0; }* Interval(int s, int e) { start = s; end = e; }* }*/class Solution { public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) { List&lt;Interval&gt; res=new ArrayList&lt;&gt;(); if(intervals.size()==0) { res.add(newInterval); return res; } for(int i=0;i&lt;intervals.size();i++) { if(newInterval.end&lt;intervals.get(i).start) { res.add(newInterval); for(int j=i;j&lt;intervals.size();j++) { res.add(intervals.get(j)); } break; } else if(intervals.get(i).end&lt;newInterval.start) { res.add(intervals.get(i)); }else { newInterval.start=Math.min(intervals.get(i).start, newInterval.start); newInterval.end=Math.max(intervals.get(i).end, newInterval.end); } if(i==intervals.size()-1) { res.add(newInterval); } } return res; }} 第58题 123456789class Solution { public int lengthOfLastWord(String s) { if(s==null||s.trim().equals(&quot;&quot;)) { return 0; } String[] srr=s.split(&quot; &quot;); return srr[srr.length-1].length(); }} 第59题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution { public int[][] generateMatrix(int n) { int[][] arr=new int[n][n]; int x=0; int y=0; boolean[][] brr=new boolean[n][n]; boolean temp=brr[0][0]; int k=1; int i=0; int j=0; while(!temp) { for(j=j;j&lt;n-y;j++) { arr[i][j]=k; brr[i][j]=true; k++; } j--; i++; if(i&gt;=n||j&gt;=n||i&lt;0||j&lt;0||brr[i][j]){ break; } for(i=i;i&lt;n-x;i++) { arr[i][j]=k; brr[i][j]=true; k++; } i--; j--; if(i&gt;=n||j&gt;=n||i&lt;0||j&lt;0||brr[i][j]){ break; } for(j=j;j&gt;=0+y;j--) { arr[i][j]=k; brr[i][j]=true; k++; } x++; y++; j++; i--; if(i&gt;=n||j&gt;=n||i&lt;0||j&lt;0||brr[i][j]){ break; } for(i=i;i&gt;=0+x;i--) { arr[i][j]=k; brr[i][j]=true; k++; } i++; j++; if(i&gt;=n||j&gt;=n||i&lt;0||j&lt;0||brr[i][j]){ break; } } return arr; }}","link":"/2018/09/10/blog27/"},{"title":"Leetcode刷题第二十六天","text":"开学第二天没课ing 第60题 12345678910111213141516171819202122232425262728293031class Solution { public String getPermutation(int n, int k) { int[] factor=new int[n]; for(int i=0;i&lt;n;i++) { if(i==0) { factor[i]=1; continue; } factor[i]=factor[i-1]*i; } int m=n-1; StringBuffer sb=new StringBuffer(); boolean[] used=new boolean[n]; while(m&gt;=0) { int idx=(k-1)/factor[m]; sb.append(fun(idx,used)); k-=idx*factor[m--]; } return sb.toString(); } public int fun(int idx,boolean[] used) { int res=-1; while(idx&gt;=0) { if(used[++res]==false) { idx--; } } used[res]=true; return res+1; }} 第61题 12345678910111213141516171819202122232425262728293031323334353637383940/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode rotateRight(ListNode head, int k) { if(head==null){ return head; } int n=1; ListNode p=head; while(p.next!=null) { n++; p=p.next; } int step=k%n; if(k==0) step=0; if(step&gt;0) { int m=1; p=head; while(m!=n-step) { p=p.next; m++; } ListNode q=p.next; p.next=null; p=q; while(p.next!=null) { p=p.next; } p.next=head; return q; } return head; }} 第62题 12345678910111213141516171819class Solution { public int uniquePaths(int m, int n) { int[][] dp=new int[m][n]; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(i==0&amp;&amp;j==0) { dp[i][j]=1; }else if(i==0&amp;&amp;j&gt;0) { dp[i][j]=dp[i][j-1]; }else if(i&gt;0&amp;&amp;j==0) { dp[i][j]=dp[i-1][j]; }else{ dp[i][j]=dp[i-1][j]+dp[i][j-1]; } } } return dp[m-1][n-1]; }}","link":"/2018/09/11/blog28/"},{"title":"Leetcode刷题第二十七天","text":"又是咸鱼的一天，自己一天真的睡的好多，明天开始早起！最近做了几道dp的题算是第一次真正理解了dp 第63题 123456789101112131415161718192021222324class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m=obstacleGrid.length; int n=obstacleGrid[0].length; int[][] dp=new int[m+1][n+1]; for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { if(i==1&amp;&amp;j==1&amp;&amp;obstacleGrid[0][0]!=1) { dp[i][j]=1; } if(obstacleGrid[i-1][j-1]==1) { continue; } if(dp[i][j-1]!=0) { dp[i][j]+=dp[i][j-1]; } if(dp[i-1][j]!=0) { dp[i][j]+=dp[i-1][j]; } } } return dp[m][n]; }} 第64题 1234567891011121314151617181920212223class Solution { public int minPathSum(int[][] grid) { int m=grid.length; int n=grid[0].length; int[][] dp=new int[m+1][n+1]; for(int i=0;i&lt;=m;i++) { for(int j=0;j&lt;=n;j++) { dp[i][j]=Integer.MAX_VALUE; } } for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { if(i==1&amp;&amp;j==1) { dp[i][j]=grid[0][0]; continue; } dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1]); dp[i][j]+=grid[i-1][j-1]; } } return dp[m][n]; }} 第65题 12345678910111213141516171819class Solution { public boolean isNumber(String s) { if(s.contains(&quot;f&quot;)) { return false; } try{ Double.valueOf(s); if(s.contains(&quot;e&quot;)) { return !s.substring(s.indexOf(&quot;e&quot;)+1).matches(&quot;.*[a-zA-z].*&quot;); } if(s.contains(&quot;D&quot;)) { return false; } return true; }catch (Exception e) { return false; } }}","link":"/2018/09/12/blog29/"},{"title":"Leetcode刷题第二十八天","text":"From zero to hero. 第66题 12345678910111213141516171819202122class Solution { public int[] plusOne(int[] digits) { int carry=0; for(int i=digits.length-1;i&gt;=0;i--) { int n=digits[i]+carry; if(i==digits.length-1){ n++; } digits[i]=n%10; carry=n/10; if(i==0&amp;&amp;carry==1) { int[] res=new int[digits.length+1]; res[0]=1; for(int j=0;j&lt;digits.length;j++) { res[i+1]=digits[i]; } return res; } } return digits; }} 第67题 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public String addBinary(String a, String b) { char[] arr=a.toCharArray(); char[] brr=b.toCharArray(); int m=arr.length-1; int n=brr.length-1; int len=Math.max(m, n); int carry=0; char[] crr=new char[len+2]; while(m&gt;=0 &amp;&amp; n&gt;=0) { int temp=(arr[m]-'0')+(brr[n]-'0')+carry; crr[len]=(char) ((char) (temp%2)+'0'); carry=temp/2; len--; m--; n--; } while(m&gt;=0) { int temp=(arr[m]-'0')+carry; crr[len]=(char) ((char) (temp%2)+'0'); carry=temp/2; len--; m--; } while(n&gt;=0) { int temp=(brr[n]-'0')+carry; crr[len]=(char) ((char) (temp%2)+'0'); carry=temp/2; len--; n--; } if(carry==1) { for(int i=crr.length-2;i&gt;=0;i--) { crr[i+1]=crr[i]; } crr[0]='1'; return new String(crr); } return new String(crr).substring(0, crr.length-1); }} 第68题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution { public List&lt;String&gt; fullJustify(String[] words, int maxWidth) { List&lt;String&gt; res=new ArrayList&lt;&gt;(); StringBuffer sb=new StringBuffer(); for(String s:words) { if(sb.length()+s.length()&gt;maxWidth) { String[] srr=sb.toString().split(&quot; &quot;); int len=0; for(String temp:srr) { len+=temp.length(); } int space_len=maxWidth-len; int space_num=srr.length-1; int[] space=new int[space_num]; int i=0,j=0; if(space_num==0){ int last=maxWidth-sb.length(); for(int k=0;k&lt;last;k++){ sb.append(&quot; &quot;); } res.add(sb.toString().substring(0, maxWidth)); sb.replace(0,sb.length(),&quot;&quot;); sb.append(s+&quot; &quot;); continue; } else if(space_len%space_num==0) { for(j=0;j&lt;space_num;j++) { space[j]=space_len/space_num; } }else { int temp_n=(space_len/space_num)+1; temp_n=(temp_n*space_num)-space_len; temp_n=space_num-temp_n; for(i=0;i&lt;temp_n;i++) { space[i]=space_len/space_num+1; } for(j=i;j&lt;space_num;j++) { space[j]=space_len/space_num; } } sb.replace(0,sb.length(), &quot;&quot;); i=0; for(String temp:srr) { sb.append(temp); if(i&lt;space.length) { for(j=0;j&lt;space[i];j++) { sb.append(&quot; &quot;); } i++; } } res.add(sb.toString()); sb.replace(0,sb.length(),&quot;&quot;); } sb.append(s+&quot; &quot;); } int last=maxWidth-sb.length(); for(int i=0;i&lt;last;i++){ sb.append(&quot; &quot;); } res.add(sb.toString().substring(0, maxWidth)); return res; }}","link":"/2018/09/13/blog30/"},{"title":"Leetcode刷题第二十九天","text":"咸鱼的一天。看了一部超级好看的电影——解除好友2，自认为是2018年最好看的电影，虽然2018还没结束，但是这部电影真的要强烈安利！ 第69题 12345class Solution { public int mySqrt(int x) { return (int) Math.sqrt(x); }} 第70题 12345678910class Solution { public int climbStairs(int n) { int[] dp=new int[n+1]; dp[0]=dp[1]=1; for(int i=2;i&lt;dp.length;i++) { dp[i]=dp[i-1]+dp[i-2]; } return dp[n]; }} 第71题 1234567891011121314151617181920212223242526272829303132333435class Solution { public String simplifyPath(String path) { Stack&lt;String&gt; stack=new Stack&lt;&gt;(); StringBuffer sb=new StringBuffer(); for(int i=0;i&lt;path.length();i++) { if(path.charAt(i)=='/') { if(sb.length()!=0) { if(sb.toString().equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) { stack.pop(); }else if(!sb.toString().equals(&quot;.&quot;) &amp;&amp; !sb.toString().equals(&quot;..&quot;)){ stack.push(sb.toString()); } sb.replace(0,sb.length(),&quot;&quot;); } continue; } sb.append(path.charAt(i)); } if(sb.length()!=0) { if(sb.toString().equals(&quot;..&quot;) &amp;&amp; !stack.isEmpty()) { stack.pop(); }else if(!sb.toString().equals(&quot;.&quot;) &amp;&amp; !sb.toString().equals(&quot;..&quot;)){ stack.push(sb.toString()); } } StringBuffer res=new StringBuffer(&quot;/&quot;); for(String s:stack) { res.append(s+&quot;/&quot;); } if(stack.isEmpty()) { return res.toString(); } return res.toString().substring(0,res.length()-1); }}","link":"/2018/09/14/blog31/"},{"title":"Leetcode刷题第三十天","text":"啊哈！30天了，养成了一个新的习惯吧！ 第72题 1234567891011121314151617181920212223class Solution { public int minDistance(String word1, String word2) { int m=word1.length(); int n=word2.length(); int[][] dp=new int[m+1][n+1]; for(int i=0;i&lt;=m;i++) { dp[i][0]=i; } for(int i=0;i&lt;=n;i++) { dp[0][i]=i; } for(int i=1;i&lt;=m;i++) { for(int j=1;j&lt;=n;j++) { if(word1.charAt(i-1)==word2.charAt(j-1)){ dp[i][j]=dp[i-1][j-1]; }else{ dp[i][j]=Math.min(dp[i-1][j-1], Math.min(dp[i-1][j],dp[i][j-1]))+1; } } } return dp[m][n]; }} 第73题 12345678910111213141516171819202122232425262728class Solution { public void setZeroes(int[][] matrix) { int m=matrix.length; int n=matrix[0].length; boolean[] flag=new boolean[m+n]; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(matrix[i][j]==0) { flag[i]=true; flag[j+m]=true; } } } for(int k=0;k&lt;flag.length;k++) { if(flag[k]) { if(k&lt;m) { for(int i=0;i&lt;n;i++) { matrix[k][i]=0; } }else { for(int i=0;i&lt;m;i++) { matrix[i][k-m]=0; } } } } }} 第74题 123456789101112131415161718192021222324252627282930313233class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m=matrix.length; if(m==0){ return false; } int n=matrix[0].length; if(n==0){ return false; } int x=0; for(int i=0;i&lt;m;i++) { if(matrix[i][0]&gt;=target) { if(matrix[i][0]==target)return true; break; } x=i; } int low=0; int high=n-1; while(low&lt;=high) { int mid=(low+high)/2; if(matrix[x][mid]==target) { return true; }else if(matrix[x][mid]&lt;target) { low=mid+1; }else { high=mid-1; } } return false; }}","link":"/2018/09/15/blog32/"},{"title":"Leetcode刷题第三十一天","text":"看完代码再来看英语，发现学习英语这种没有逻辑只要记忆的东西真是太幸福了！ 第905题123456789101112131415161718class Solution { public int[] sortArrayByParity(int[] A) { int begin=0; int end=A.length-1; int[] res=new int[A.length]; for(int t:A) { if(begin&gt;end) { break; } if(t%2==0) { res[begin++]=t; }else { res[end--]=t; } } return res; }} 第907题12345678910111213141516171819202122232425262728class Solution { public int sumSubarrayMins(int[] A) { int[] num=new int[A.length]; for(int i=0;i&lt;A.length;i++) { int right=0; for(int j=i+1;j&lt;A.length;j++) { if(A[j]&lt;A[i]) { break; } right++; } int left=0; for(int j=i-1;j&gt;=0;j--) { if(A[j]&lt;=A[i]) { break; } left++; } num[i]=left+right+1+left*right; } int sum=0; for(int i=0;i&lt;A.length;i++) { sum+=num[i]*A[i]; sum=sum%1000000007; } return sum; }}","link":"/2018/09/16/blog33/"},{"title":"Leetcode刷题第三十二天","text":"步步为营 第906题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Solution { public int totalFruit(int[] tree) { if (tree.length == 0) { return 0; } int[] buffer = new int[2]; int[] count = new int[2]; int i = 0; buffer[0] = tree[0]; count[0] = 1; int max = 0; for (i = 1; i &lt; tree.length; i++) { if (tree[i] != tree[0]) { buffer[1] = tree[i]; break; } count[0]++; } if (i == tree.length) { return tree.length; } count[1] = 1; max = count[0] + count[1]; for (int j = i + 1; j &lt; tree.length; j++) { if (tree[j] != buffer[0] &amp;&amp; tree[j] != buffer[1]) { if (count[0] + count[1] &gt; max) { max = count[0] + count[1]; } if (tree[j - 1] == buffer[0]) { count[1] = 1; buffer[1] = tree[j]; count[0]=1; for(int k=j-2;k&gt;=0;k--) { if(tree[k]==buffer[0]) { count[0]++; }else{ break; } } } else { count[0] = 1; buffer[0] = tree[j]; count[1]=1; for(int k=j-2;k&gt;=0;k--) { if(tree[k]==buffer[1]) { count[1]++; }else{ break; } } } continue; } if (tree[j] == buffer[0]) { count[0]++; } else if (tree[j] == buffer[1]) { count[1]++; } if (j == tree.length - 1) { if (count[0] + count[1] &gt; max) { max = count[0] + count[1]; } } } return max; }}","link":"/2018/09/17/blog34/"},{"title":"Leetcode刷题第三十三天","text":"困困困，累累累，休息了 第75题 1234567891011121314151617181920212223class Solution { public void sortColors(int[] nums) { int left=0; int right=nums.length-1; int i=0; while(i&lt;=right) { if(nums[i]==1) { i++; }else if(nums[i]==0) { int temp=nums[left]; nums[left]=nums[i]; nums[i]=temp; left++; i++; }else { int temp=nums[right]; nums[right]=nums[i]; nums[i]=temp; right--; } } }} 第76题 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { public String minWindow(String s, String t) { Map&lt;Character,Integer&gt; tmap=new HashMap&lt;&gt;(); Map&lt;Character,Integer&gt; smap=new HashMap&lt;&gt;(); for(int i=0;i&lt;t.length();i++) { int value=1; if(tmap.containsKey(t.charAt(i))) { value=tmap.get(t.charAt(i))+1; } tmap.put(t.charAt(i), value); } String res=&quot;&quot;; int j=0; for(int i=0;i&lt;=s.length();) { if(isOk(smap,tmap)) { if(res.equals(&quot;&quot;) || res.length()&gt;s.substring(j,i).length()){ res=s.substring(j, i); } int value=smap.get(s.charAt(j))-1; smap.put(s.charAt(j), value); j++; }else if(i==s.length()){ break; }else { int value=1; if(smap.containsKey(s.charAt(i))) { value=smap.get(s.charAt(i))+1; } smap.put(s.charAt(i), value); i++; } } return res; } public boolean isOk(Map&lt;Character,Integer&gt; smap,Map&lt;Character,Integer&gt; tmap) { for (Map.Entry&lt;Character, Integer&gt; entry : tmap.entrySet()) { if(smap.get(entry.getKey())==null || tmap.get(entry.getKey())&gt;smap.get(entry.getKey())) { return false; } } return true; }}","link":"/2018/09/18/blog35/"},{"title":"Leetcode刷题第三十四天","text":"推荐歌曲:I Don’t Have Time to Be Love 第77题 12345678910111213141516171819class Solution { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { fun(0,n,k,new ArrayList&lt;&gt;()); return res; } public void fun(int idx,int n,int k,List&lt;Integer&gt; list) { if(list.size()==k) { res.add(new ArrayList&lt;Integer&gt;(list)); return; } for(int i=idx;i&lt;n-(k-list.size())+1;i++) { list.add(i+1); fun(i+1,n,k,list); list.remove(list.size()-1); } }} 第78题 123456789101112131415161718192021class Solution { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { for(int i=0;i&lt;=nums.length;i++) { fun(0,nums,i,new ArrayList&lt;Integer&gt;()); } return res; } public void fun(int idx,int[] nums,int k,List&lt;Integer&gt; list) { if(list.size()==k) { res.add(new ArrayList&lt;&gt;(list)); return; } for(int i=idx;i&lt;nums.length-(k-list.size())+1;i++) { list.add(nums[i]); fun(i+1,nums,k,list); list.remove(list.size()-1); } }} 第79题 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public boolean exist(char[][] board, String word) { for(int i=0;i&lt;board.length;i++) { for(int j=0;j&lt;board[0].length;j++) { if(board[i][j]==word.charAt(0)) { boolean[][] flag=new boolean[board.length][board[0].length]; if(dfs(i,j,board,word,0,flag)) { return true; } } } } return false; } public boolean dfs(int x,int y,char[][] board,String word,int idx,boolean[][] flag) { if(idx==word.length()) { return true; } if(x&lt;0 || y&lt;0 || x==board.length || y==board[0].length || flag[x][y] || word.charAt(idx)!=board[x][y]) { return false; } flag[x][y]=true; if(dfs(x+1,y,board,word,idx+1,flag)) { return true; } if(dfs(x,y+1,board,word,idx+1,flag)) { return true; } if(dfs(x-1,y,board,word,idx+1,flag)) { return true; } if(dfs(x,y-1,board,word,idx+1,flag)) { return true; } flag[x][y]=false; return false; }}","link":"/2018/09/19/blog36/"},{"title":"Leetcode刷题第三十五天","text":"烦躁的一天。 第80题 12345678910111213141516171819202122232425class Solution { public int removeDuplicates(int[] nums) { int res=nums.length; for(int i=0;i&lt;res;) { int t=nums[i]; int count=0; for(int j=i+1;j&lt;res;j++) { if(nums[j]!=t) { break; } count++; } if(count&gt;1) { for(int k=i+count;k&lt;res;k++) { nums[k-(count-2)-1]=nums[k]; } res=res-(count-2+1); i=i+2; }else { i=i+1+count; } } return res; }} 第81题 1234567891011121314151617181920212223242526class Solution { public boolean search(int[] nums, int target) { int st=0; int end=nums.length-1; while(st&lt;=end) { int mid=(st+end)/2; if(nums[mid]==target)return true; if(nums[st]&lt;nums[mid]) { if(nums[st]&lt;=target&amp;&amp;target&lt;=nums[mid]) { end=mid-1; }else { st=mid+1; } }else if(nums[st]&gt;nums[mid]){ if(nums[mid]&lt;=target&amp;&amp;target&lt;=nums[end]) { st=mid+1; }else { end = mid-1; } }else{ st++; } } return false; }}","link":"/2018/09/20/blog37/"},{"title":"Leetcode刷题第三十六天","text":"昨天出去吃烤肉然后回家就没有做题，今天做题头脑很混乱，感觉自己真的是一个做事没有逻辑的人，难道自己更适合做一个浪漫风骚的文科生？ 第82题 12345678910111213141516171819202122232425262728293031323334/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode deleteDuplicates(ListNode head) { if(head==null || head.next==null) { return head; } ListNode newHead=new ListNode(0); ListNode cur=newHead; while(head!=null) { ListNode p=head; int count=0; while(p.next!=null &amp;&amp; p.val==p.next.val) { count++; p=p.next; } if(count==0) { cur.next=head; head=head.next; cur=cur.next; }else { head=p.next; } } cur.next=null; return newHead.next; }} 第83题 123456789101112131415161718192021222324252627/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode deleteDuplicates(ListNode head) { if(head==null || head.next==null) { return head; } ListNode newHead=new ListNode(0); ListNode cur=newHead; while(head!=null) { cur.next=head; cur=cur.next; while(head.next!=null &amp;&amp; head.next.val==head.val) { head=head.next; } head=head.next; } cur.next=null; return newHead.next; }} 第84题 1234567891011121314151617181920212223class Solution { public int largestRectangleArea(int[] heights) { if(heights.length==0){ return 0; } int max=heights[0]; for(int i=1;i&lt;heights.length;i++) { if(i + 1 &lt; heights.length &amp;&amp; heights[i] &lt;= heights[i + 1]) { continue; } int min=heights[i]; for(int j=i;j&gt;=0;j--) { if(min&gt;heights[j]) { min=heights[j]; } if(max&lt;(i-j+1)*min) { max=(i-j+1)*min; } } } return max; }}","link":"/2018/09/22/blog38/"},{"title":"Leetcode刷题第三十七天","text":"又是一周的周赛，水平依旧垃圾。在家真的各种懒，看网课一会儿就困了。。。加油吧！ 第908题1234567891011121314class Solution { public int smallestRangeI(int[] A, int K) { Arrays.sort(A); int min=A[A.length-1]-A[0]; int temp=(A[A.length-1]-K)-(A[0]+K); if(temp&lt;=0) { return 0; } if(temp&lt;min) { min=temp; } return min; }} 第910题12345678910class Solution { public int smallestRangeII(int[] A, int K) { Arrays.sort(A); int min=A[A.length-1]-A[0]; for(int i=0;i&lt;A.length-1;i++) { min=Math.min(min, Math.max(A[A.length-1]-K, A[i]+K)-Math.min(A[0]+K, A[i+1]-K)); } return min; }}","link":"/2018/09/23/blog39/"},{"title":"Leetcode刷题第三十八天","text":"第85题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution { public int maximalRectangle(char[][] matrix) { int m=matrix.length; if(m==0) { return 0; } int n=matrix[0].length; int max=Integer.MIN_VALUE; for(int i=0;i&lt;m;i++) { int height[] =new int[n]; for(int j=0;j&lt;n;j++) { if(matrix[i][j]=='0') { height[j]=0; continue; } int temp=0; for(int k=i;k&gt;=0;k--) { if(matrix[k][j]=='0') { break; } temp++; } height[j]=temp; } int temp=largestRectangleArea(height); if(temp&gt;max) { max=temp; } } return max; } public int largestRectangleArea(int[] heights) { if (heights.length == 0) { return 0; } int max = heights[0]; for (int i = 1; i &lt; heights.length; i++) { if (i + 1 &lt; heights.length &amp;&amp; heights[i] &lt;= heights[i + 1]) { continue; } int min = heights[i]; for (int j = i; j &gt;= 0; j--) { if (min &gt; heights[j]) { min = heights[j]; } if (max &lt; (i - j + 1) * min) { max = (i - j + 1) * min; } } } return max; }} 第86题 1234567891011121314151617181920212223242526272829303132/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode partition(ListNode head, int x) { ListNode res=new ListNode(0); ListNode p=res; ListNode q=head; while(q!=null) { if(q.val&lt;x) { p.next=new ListNode(q.val); p=p.next; } q=q.next; } q=head; while(q!=null) { if(q.val&gt;=x) { p.next=new ListNode(q.val); p=p.next; } q=q.next; } p.next=null; return res.next; }}","link":"/2018/09/26/blog40/"},{"title":"Leetcode刷题第三十九天","text":"第87题 123456789101112131415161718192021222324class Solution { public boolean isScramble(String s1, String s2) { if(s1.length()!=s2.length())return false; if(s1.equals(s2))return true; String str1=s1; String str2=s2; char[] cstr1=str1.toCharArray(); char[] cstr2=str2.toCharArray(); Arrays.sort(cstr1); Arrays.sort(cstr2); if(!new String(cstr1).equals(new String(cstr2))) return false; for(int i=1;i&lt;s1.length();i++) { String s11=s1.substring(0,i); String s12=s1.substring(i); String s21=s2.substring(0,i); String s22=s2.substring(i); if(isScramble(s11, s21)&amp;&amp;isScramble(s12, s22))return true; s21=s2.substring(s2.length()-i); s22=s2.substring(0,s2.length()-i); if(isScramble(s11, s21)&amp;&amp;isScramble(s12, s22))return true; } return false; }} 第88题 12345678910111213141516171819202122class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int[] temp=new int[m+n]; int i=0,j=0,k=0; while(i&lt;m || j&lt;n) { if(j==n) { temp[k++]=nums1[i++]; }else if(i==m) { temp[k++]=nums2[j++]; }else { if(nums1[i]&lt;nums2[j]) { temp[k++]=nums1[i++]; }else{ temp[k++]=nums2[j++]; } } } for(i=0;i&lt;m+n;i++) { nums1[i]=temp[i]; } }} 第89题 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public List&lt;Integer&gt; grayCode(int n) { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(n==0) { res.add(0); return res; } String[] rs=fun(n); for(String s:rs) { int buff=n-1; int num=0; for(int i=0;i&lt;s.length();i++) { num+=(s.charAt(i)-'0')*Math.pow(2, buff); buff--; } res.add(num); } return res; } public String[] fun(int n) { if(n==1) { String[] arr=new String[2]; arr[0]=&quot;0&quot;; arr[1]=&quot;1&quot;; return arr; } String arr[]=fun(n-1); int num=(int) Math.pow(2,n); String brr[]=new String[num]; for(int i=0;i&lt;num/2;i++) { brr[i]=&quot;0&quot;+arr[i]; } int j=arr.length-1; for(int i=num/2;i&lt;num;i++) { brr[i]=&quot;1&quot;+arr[j]; j--; } return brr; }}","link":"/2018/09/27/blog41/"},{"title":"Leetcode刷题第四十天","text":"第90题 1234567891011121314151617181920212223242526class Solution { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { int i=0; Arrays.sort(nums); while(i&lt;=nums.length) { fun(0,i,nums,new ArrayList&lt;Integer&gt;()); i++; } return res; } public void fun(int idx,int n,int[] nums,List&lt;Integer&gt; list) { if(idx==n) { List&lt;Integer&gt; temp=new ArrayList&lt;&gt;(list); res.add(temp); return; } for(int i=idx;i&lt;nums.length;i++) { if(i!=idx&amp;&amp;nums[i-1]==nums[i])continue; list.add(nums[i]); fun(i+1,n,nums,list); list.remove(list.size()-1); } }} 第91题 123456789101112131415161718class Solution { public int numDecodings(String s) { char[] arr=s.toCharArray(); int[] dp=new int[arr.length+1]; dp[0]=1; for(int i=1;i&lt;dp.length;i++) { if(arr[i-1]=='0') { dp[i]=0; }else { dp[i]=dp[i-1]; } if(i&gt;1 &amp;&amp; (arr[i-2]=='1'||(arr[i-2]=='2'&amp;&amp;arr[i-1]&lt;='6'))) { dp[i]+=dp[i-2]; } } return dp[dp.length-1]; }}","link":"/2018/09/28/blog42/"},{"title":"Leetcode刷题第四十一天","text":"好久没更了，周赛也因为国庆节前放假补课没有参加。 第914题12345678910111213141516171819202122class Solution { public boolean hasGroupsSizeX(int[] deck) { int[] f = new int[10001]; for(int d : deck){ f[d]++; } int g = 0; for(int v : f){ g = gcd(g, v); } return g != 1; } public int gcd(int a, int b) { while (b &gt; 0) { int c = a; a = b; b = c % b; } return a; }} 第92题 123456789101112131415161718192021222324252627282930313233343536373839/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode reverseBetween(ListNode head, int m, int n) { ListNode res=new ListNode(0); res.next=head; ListNode pLast=null; ListNode pHead=res; ListNode p=null; ListNode temp=null; int len=0; while(head!=null) { if(++len&lt;m) { pHead=head; head=head.next; }else if(len==m) { p=pLast=head; head=head.next; pLast.next=null; }else if(m&lt;=len &amp;&amp; len&lt;=n) { temp=head; head=head.next; temp.next=p; p=temp; pHead.next=p; }else { pLast.next=head; break; } } return res.next; }} 第93题 12345678910111213141516171819202122232425262728293031323334353637class Solution { List&lt;String&gt; res=new ArrayList&lt;&gt;(); public List&lt;String&gt; restoreIpAddresses(String s) { helper(s,&quot;&quot;,3); return res; } public void helper(String s,String result,int k) { if(s.length()&lt;k+1) { return; } if(s.length()&gt;3*(k+1)) { return; } if(k==0) { if(Integer.parseInt(s)&gt;=256 || (s.charAt(0)=='0'&amp;&amp;s.length()&gt;1)) { return; } res.add(result+&quot;.&quot;+s); return; } for(int i=1;i&lt;=s.length();i++) { String temp=s.substring(0,i); if(Integer.parseInt(temp)&lt;256) { if(temp.length()&gt;1 &amp;&amp; temp.charAt(0)=='0') { return; } if(k&lt;3) { temp=result+&quot;.&quot;+temp; } helper(s.substring(i),temp,k-1); }else { break; } } }} 第94题 12345678910111213141516171819202122232425/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { fun(root); return res; } public void fun(TreeNode root) { if(root==null) { return; } fun(root.left); res.add(root.val); fun(root.right); }}","link":"/2018/10/02/blog43/"},{"title":"Leetcode刷题第四十二天","text":"第95题 123456789101112131415161718192021222324252627282930313233343536/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public List&lt;TreeNode&gt; generateTrees(int n) { if(n==0)return new ArrayList&lt;TreeNode&gt;(); return generate(1,n); } public ArrayList&lt;TreeNode&gt; generate(int start,int end){ ArrayList&lt;TreeNode&gt; rst=new ArrayList&lt;&gt;(); if(start&gt;end) { rst.add(null); return rst; } for(int i=start;i&lt;=end;i++) { ArrayList&lt;TreeNode&gt; left=generate(start,i-1); ArrayList&lt;TreeNode&gt; right=generate(i+1, end); for(TreeNode l:left) { for(TreeNode r:right) { TreeNode root=new TreeNode(i); root.left=l; root.right=r; rst.add(root); } } } return rst; }} 第96题 12345678910111213class Solution { public int numTrees(int n) { int[] dp=new int[n+1]; dp[0]=1; dp[1]=1; for(int i=2;i&lt;=n;i++) { for(int j=0;j&lt;i;j++) { dp[i]+=dp[j]*dp[i-j-1]; } } return dp[n]; }}","link":"/2018/10/03/blog44/"},{"title":"Leetcode刷题第四十三天","text":"最近做题的三大杀手——链表、二叉树、DP。。。 第97题 12345678910111213141516171819202122232425class Solution { public boolean isInterleave(String s1, String s2, String s3) { if(s1.length()+s2.length()!=s3.length()) { return false; } boolean[][] dp = new boolean[s2.length() + 1][s1.length() + 1]; dp[0][0] = true; for (int i = 0; i &lt;= s2.length(); i++) { for (int j = 0; j &lt;= s1.length(); j++) { if(i==0&amp;&amp;j==0)continue; if(i&gt;0) { if(s2.charAt(i-1)==s3.charAt(i+j-1)) { dp[i][j]=dp[i][j]||dp[i-1][j]; } } if(j&gt;0) { if(s1.charAt(j-1)==s3.charAt(i+j-1)) { dp[i][j]=dp[i][j]||dp[i][j-1]; } } } } return dp[s2.length()][s1.length()]; }} 第98题 123456789101112131415161718192021222324/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public boolean isValidBST(TreeNode root) { return fun(root,Long.MIN_VALUE,Long.MAX_VALUE); } public boolean fun(TreeNode root,long min,long max) { if(root==null) { return true; } if(root.val&lt;=min || root.val&gt;=max) { return false; } return fun(root.left,min,root.val) &amp;&amp; fun(root.right,root.val,max); }} 第99题 1234567891011121314151617181920212223242526272829303132333435/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { TreeNode pre=null; TreeNode first=null; TreeNode second=null; public void recoverTree(TreeNode root) { fun(root); int temp=first.val; first.val=second.val; second.val=temp; } public void fun(TreeNode root) { if(root==null)return; fun(root.left); if(pre!=null) { if(first==null &amp;&amp; pre.val&gt;root.val) { first=pre; } if(first!=null &amp;&amp; pre.val&gt;root.val) { second=root; } } pre=root; fun(root.right); }}","link":"/2018/10/04/blog45/"},{"title":"Leetcode刷题第四十四天","text":"属于二叉树的一天，100题啦！ 第100题 1234567891011121314151617181920212223/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { return fun(p,q); } public boolean fun(TreeNode p,TreeNode q) { if(p==null || q==null){ if(p==null &amp;&amp; q==null)return true; return false; } if(p.val!=q.val)return false; return fun(q.left,p.left) &amp;&amp; fun(q.right,p.right); }} 第101题 12345678910111213141516171819202122232425/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public boolean isSymmetric(TreeNode root) { if(root==null)return true; return fun(root.left,root.right); } public boolean fun(TreeNode p, TreeNode q) { if (p == null || q == null) { if(p==null &amp;&amp; q==null)return true; return false; } if (p.val != q.val) return false; return fun(p.left,q.right) &amp;&amp; fun(p.right,q.left); }} 第102题 123456789101112131415161718192021222324252627282930/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); if(root==null) return res; List&lt;TreeNode&gt; list=new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; temp=new ArrayList&lt;&gt;(); list.add(root); while(list.size()!=0) { List&lt;Integer&gt; ls=new ArrayList&lt;&gt;(); for(TreeNode t:list) { ls.add(t.val); if(t.left!=null)temp.add(t.left); if(t.right!=null)temp.add(t.right); } res.add(ls); list=new ArrayList&lt;&gt;(temp); temp=new ArrayList&lt;&gt;(); } return res; }} 第103题 12345678910111213141516171819202122232425262728293031323334353637383940/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if (root == null) return res; List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; temp = new ArrayList&lt;&gt;(); list.add(root); boolean flag=false; while (list.size() != 0) { List&lt;Integer&gt; ls = new ArrayList&lt;&gt;(); for (int i=0;i&lt;list.size();i++) { TreeNode t=list.get(i); if(flag) { ls.add(list.get(list.size()-1-i).val); }else { ls.add(t.val); } if (t.left != null) temp.add(t.left); if (t.right != null) temp.add(t.right); } flag=!flag; res.add(ls); list = new ArrayList&lt;&gt;(temp); temp = new ArrayList&lt;&gt;(); } return res; }} 第104题 12345678910111213141516171819/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public int maxDepth(TreeNode root) { return deepth(root); } public int deepth(TreeNode root) { if(root==null)return 0; return Math.max(deepth(root.left),deepth(root.right))+1; }}","link":"/2018/10/05/blog46/"},{"title":"Leetcode刷题第四十五天","text":"傻妞，啥时候才能变聪明一点呢？ 第105题 12345678910111213141516171819202122232425262728293031323334353637383940414243/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if(preorder.length==0||inorder.length==0)return null; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); int n=preorder.length; boolean flag=true; TreeNode node=new TreeNode(preorder[0]); TreeNode res=node; if(preorder.length==1)return res; stack.push(node); int i=1,j=0; while(i&lt;n) { if(!stack.isEmpty() &amp;&amp; inorder[j]==stack.peek().val) { node=stack.peek(); stack.pop(); flag=false; j++; }else { TreeNode t=new TreeNode(preorder[i]); stack.push(t); i++; if(flag) { node.left=t; node=node.left; }else { node.right=t; node=node.right; flag=true; } } } return res; }} 第106题 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { if(inorder.length==0 || postorder.length==0)return null; Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;(); int n=postorder.length-1; TreeNode node=new TreeNode(postorder[n]); TreeNode res=node; if(n==0)return res; int i=n-1; int j=inorder.length-1; boolean flag=true; stack.push(node); while(i&gt;=0) { if(!stack.isEmpty() &amp;&amp; inorder[j]==stack.peek().val) { node=stack.peek(); stack.pop(); j--; flag=false; }else { TreeNode t=new TreeNode(postorder[i]); stack.push(t); i--; if(flag) { node.right=t; node=node.right; }else { node.left=t; node=node.left; flag=true; } } } return res; }} 第107题 123456789101112131415161718192021222324252627282930313233/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); if(root==null)return res; List&lt;List&lt;Integer&gt;&gt; tmp=new ArrayList&lt;&gt;(); List&lt;TreeNode&gt; list=new ArrayList&lt;&gt;(); list.add(root); while(!list.isEmpty()) { List&lt;TreeNode&gt; temp=new ArrayList&lt;&gt;(); List&lt;Integer&gt; ls=new ArrayList&lt;&gt;(); for(TreeNode t:list) { ls.add(t.val); if(t.left!=null)temp.add(t.left); if(t.right!=null)temp.add(t.right); } tmp.add(ls); list=temp; } for(int i=tmp.size()-1;i&gt;=0;i--) { res.add(tmp.get(i)); } return res; }}","link":"/2018/10/06/blog47/"},{"title":"Leetcode刷题第四十六天","text":"又是一周周赛，国庆节也完了 第917题1234567891011121314151617class Solution { public String reverseOnlyLetters(String S) { char[] crr=S.toCharArray(); String tmp=S; int j=0; for(int i=tmp.length()-1;i&gt;=0;i--) { if(tmp.charAt(i)&gt;'z'||(tmp.charAt(i)&gt;'Z'&amp;&amp;tmp.charAt(i)&lt;'a')||tmp.charAt(i)&lt;'A') { continue; } while(crr[j]&gt;'z'||(crr[j]&gt;'Z'&amp;&amp;crr[j]&lt;'a')||crr[j]&lt;'A') { j++; } crr[j++]=tmp.charAt(i); } return new String(crr); }} 第918题1234567891011121314151617181920212223242526272829303132class Solution { public int maxSubarraySumCircular(int[] A) { int max1,max2; max1=maxSubArray(A); int suma=0; int len=A.length; int[] B=new int[len]; for(int i=0;i&lt;len;i++) { suma+=A[i]; B[i]=-A[i]; } max2=maxSubArray(B); max2=max2+suma; if(max2==0)return max1; return (max1&gt;max2)?max1:max2; } public int maxSubArray(int[] nums) { int current = nums[0]; int sum = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (current &lt; 0) current = nums[i]; else current += nums[i]; if (current &gt; sum) sum = current; } return sum; }} 以下为uwi的代码第917题12345678910111213141516171819class Solution { public String reverseOnlyLetters(String S) { char[] s = S.toCharArray(); for(int i = 0, j = s.length-1;i &lt; j;i++,j--){ while(i &lt; s.length &amp;&amp; !ok(s[i]))i++; while(j &gt;= 0 &amp;&amp; !ok(s[j]))j--; if(i &lt; j){ char d = s[i]; s[i] = s[j]; s[j] = d; } } return new String(s); } boolean ok(char c) { return c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z'; }} 第918题1234567891011121314151617181920212223class Solution { public int maxSubarraySumCircular(int[] A) { int n = A.length; long[] cum = new long[2*n+1]; for(int i = 0;i &lt; 2*n;i++){ cum[i+1] = cum[i] + A[i%n]; } PriorityQueue&lt;long[]&gt; pq = new PriorityQueue&lt;&gt;( 100000, (x, y) -&gt; Long.compare(x[0], y[0])); long max = Long.MIN_VALUE; for(int i = 0;i &lt; 2*n;i++){ if(i-n &gt;= 0){ while(!pq.isEmpty() &amp;&amp; pq.peek()[1] &lt; i-n){ pq.poll(); } max = Math.max(max, cum[i] - pq.peek()[0]); } pq.add(new long[]{cum[i], i}); } return (int)max; }} 第919题12345678910111213141516171819202122232425262728293031323334353637383940class CBTInserter { int sz; TreeNode root; public CBTInserter(TreeNode root) { this.root = root; sz = count(root); } public int count(TreeNode x) { if(x == null)return 0; return count(x.left) + 1 + count(x.right); } public int insert(int v) { sz++; TreeNode x = new TreeNode(v); TreeNode cur = root; TreeNode par = null; for(int i = 30-Integer.numberOfLeadingZeros(sz);i &gt;= 0;i--){ par = cur; if(sz&lt;&lt;~i&lt;0){ cur = cur.right; }else{ cur = cur.left; } } if(sz&lt;&lt;~0&lt;0){ par.right = x; }else{ par.left = x; } return par.val; } public TreeNode get_root() { return root; }} 第920题1234567891011121314151617181920class Solution { public int numMusicPlaylists(int N, int L, int K) { int mod = 1000000007; long[] dp = new long[N+1]; dp[0] = 1; for(int i = 0;i &lt; L;i++){ long[] ndp = new long[N+1]; for(int j = 0;j &lt; N;j++){ ndp[j+1] += dp[j] * (N-j); ndp[j+1] %= mod; } for(int j = 0;j &lt;= N;j++){ ndp[j] += dp[j] * Math.max(j-K, 0); ndp[j] %= mod; } dp = ndp; } return (int)dp[N]; }}","link":"/2018/10/07/blog48/"},{"title":"Leetcode刷题第四十七天","text":"想买足球鞋 第108题 123456789101112131415161718192021222324252627282930313233343536373839404142434445/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public TreeNode sortedArrayToBST(int[] nums) { if(nums.length==0)return null; int mid=(nums.length-1)/2; TreeNode root=new TreeNode(nums[mid]); fun(0,nums.length-1,nums,root); return root; } public void fun(int start,int end,int[] nums,TreeNode root) { if(start&gt;end) { return; } int mid=(start+end)/2; TreeNode t=new TreeNode(nums[mid]); insert(root,t); fun(start,mid-1,nums,root); fun(mid+1,end,nums,root); } public void insert(TreeNode root,TreeNode t) { if(root.left==null &amp;&amp; t.val&lt;root.val) { root.left=t; return; } if(root.right==null&amp;&amp;t.val&gt;root.val) { root.right=t; return; } if(t.val&lt;root.val) { insert(root.left,t); }else if(t.val&gt;root.val){ insert(root.right,t); } }} 第109题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*//*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public TreeNode sortedListToBST(ListNode head) { List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); while(head!=null) { list.add(head.val); head=head.next; } int nums[]=new int[list.size()]; for(int i=0;i&lt;list.size();i++) { nums[i]=list.get(i); } return sortedArrayToBST(nums); } public TreeNode sortedArrayToBST(int[] nums) { if (nums.length == 0) return null; TreeNode root=fun(0, nums.length - 1, nums); return root; } public TreeNode fun(int start, int end, int[] nums) { if(start&gt;end) { return null; } int mid=(start+end)/2; TreeNode root=new TreeNode(nums[mid]); root.left=fun(start,mid-1,nums); root.right=fun(mid+1,end,nums); return root; }}","link":"/2018/10/08/blog49/"},{"title":"Leetcode刷题第四十八天","text":"哇，转眼快两个月没刷题了，大三真的有够忙的，经过了这魔鬼般课程满满的两个月，终于有时间做下自己的事情了！ 第110题 12345678910111213141516171819202122232425262728293031/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public boolean isBalanced(TreeNode root) { return find(root); } public boolean find(TreeNode root) { if(root==null) { return true; } if(find(root.left)&amp;&amp;find(root.right)&amp;&amp;Math.abs(height(root.left)-height(root.right))&lt;=1){ return true; } return false; } public int height(TreeNode root) { if(root==null) { return 0; } return Math.max(height(root.left),height(root.right))+1; }} 第111题 123456789101112131415161718192021222324/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public int minDepth(TreeNode root) { if (root == null) { return 0; } if(root.left==null &amp;&amp; root.right==null)return 1; if(root.left==null) { return minDepth(root.right)+1; }else if(root.right==null) { return minDepth(root.left)+1; }else { return Math.min(minDepth(root.left), minDepth(root.right)) + 1; } }} 第112题 1234567891011121314151617181920212223242526272829303132/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public boolean hasPathSum(TreeNode root, int sum) { if(root==null) { return false; } return search(root,sum,0); } public boolean search(TreeNode root,int sum,int cur) { cur+=root.val; if(cur==sum &amp;&amp; root.left==null &amp;&amp; root.right==null) { return true; } if(root.left!=null &amp;&amp; search(root.left,sum,cur)) { return true; } if(root.right!=null &amp;&amp; search(root.right,sum,cur)) { return true; } cur-=root.val; return false; }} 第113题 1234567891011121314151617181920212223242526272829303132333435/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) { if(root==null) { return res; } search(root, sum, 0, new ArrayList&lt;Integer&gt;()); return res; } public void search(TreeNode root, int sum, int cur,List&lt;Integer&gt; list) { cur += root.val; list.add(root.val); if (cur == sum &amp;&amp; root.left == null &amp;&amp; root.right == null) { res.add(new ArrayList&lt;&gt;(list)); } if (root.left != null) { search(root.left, sum, cur,list); } if (root.right != null) { search(root.right, sum, cur,list); } cur -= root.val; list.remove(list.size()-1); }} 第114题 1234567891011121314151617181920212223/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public void flatten(TreeNode root) { if (root==null) return; if (root.left!=null) flatten(root.left); if (root.right!=null) flatten(root.right); TreeNode tmp = root.right; root.right = root.left; root.left = null; while (root.right!=null) { root = root.right; } root.right = tmp; }} 第115题 1234567891011121314151617181920212223class Solution { public int numDistinct(String s, String t) { int len1=t.length(); int len2=s.length(); int dp[][]=new int[len1+1][len2+1]; for(int i=0;i&lt;len2+1;i++) { dp[0][i]=1; } for(int i=1;i&lt;len1+1;i++) { dp[i][0]=0; } for(int i=1;i&lt;len1+1;i++) { for(int j=1;j&lt;len2+1;j++) { if(t.charAt(i-1)!=s.charAt(j-1)) { dp[i][j]=dp[i][j-1]; }else { dp[i][j]=dp[i-1][j-1]+dp[i][j-1]; } } } return dp[len1][len2]; }}","link":"/2018/11/26/blog50/"},{"title":"Leetcode刷题第四十九天","text":"第116题 12345678910111213141516171819202122/** * Definition for binary tree with next pointer. * public class TreeLinkNode { * int val; * TreeLinkNode left, right, next; * TreeLinkNode(int x) { val = x; } * } */public class Solution { public void connect(TreeLinkNode root) { TreeLinkNode level_start=root; while(level_start!=null){ TreeLinkNode cur=level_start; while(cur!=null){ if(cur.left!=null) cur.left.next=cur.right; if(cur.right!=null &amp;&amp; cur.next!=null) cur.right.next=cur.next.left; cur=cur.next; } level_start=level_start.left; } }}","link":"/2018/11/27/blog51/"},{"title":"Leetcode刷题第五十天","text":"第117题 123456789101112131415161718192021222324252627282930/*** Definition for binary tree with next pointer.* public class TreeLinkNode {* int val;* TreeLinkNode left, right, next;* TreeLinkNode(int x) { val = x; }* }*/public class Solution { public void connect(TreeLinkNode root) { TreeLinkNode queue = root; TreeLinkNode level = new TreeLinkNode(0); while (queue != null) { level.next = null; TreeLinkNode current = level; while (queue != null) { if (queue.left != null) { current.next = queue.left; current = current.next; } if (queue.right != null) { current.next = queue.right; current = current.next; } queue = queue.next; } queue = level.next; } }} 第118题 12345678910111213141516171819202122232425262728class Solution { List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { int n=1; while(n&lt;=numRows) { List&lt;Integer&gt; tmp=new ArrayList&lt;&gt;(); if(n==1) { tmp.add(1); } else if(n==2) { tmp.add(1); tmp.add(1); } else { for(int i=0;i&lt;n;i++) { if(i==0||i==n-1) { tmp.add(1); continue; } tmp.add(res.get(n-2).get(i-1)+res.get(n-2).get(i)); } } res.add(tmp); n++; } return res; }} 第119题 1234567891011121314151617181920212223242526class Solution {List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; getRow(int rowIndex) { int n = 1; while (n &lt;= rowIndex+1) { List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); if (n == 1) { tmp.add(1); } else if (n == 2) { tmp.add(1); tmp.add(1); } else { for (int i = 0; i &lt; n; i++) { if (i == 0 || i == n - 1) { tmp.add(1); continue; } tmp.add(res.get(n - 2).get(i - 1) + res.get(n - 2).get(i )); } } res.add(tmp); n++; } return res.get(rowIndex); }} 第120题 123456789101112class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int n=triangle.size(); for(int i=n-2;i&gt;=0;i--) { int m=triangle.get(i).size(); for(int j=0;j&lt;m;j++) { triangle.get(i).set(j, triangle.get(i).get(j)+Math.min(triangle.get(i+1).get(j),triangle.get(i+1).get(j+1))); } } return triangle.get(0).get(0); }}","link":"/2018/11/28/blog52/"},{"title":"Leetcode刷题第五十一天","text":"转眼19年了，赶紧刷点题！ 第121题 123456789101112131415class Solution { public int maxProfit(int[] prices) { if(prices.length==0)return 0; int dp[]=new int[prices.length]; dp[0]=0; int maxValue=dp[0]; int lowestPrice=prices[0]; for(int i=1;i&lt;prices.length;i++){ dp[i]=Math.max(maxValue,prices[i]-lowestPrice); if(dp[i]&gt;maxValue)maxValue=dp[i]; if(lowestPrice&gt;prices[i])lowestPrice=prices[i]; } return dp[prices.length-1]; }} 第122题 123456789class Solution { public int maxProfit(int[] prices) { int sum=0; for(int i=1;i&lt;prices.length;i++){ if(prices[i]&gt;prices[i-1])sum+=prices[i]-prices[i-1]; } return sum; }} 第123题 12345678910111213141516171819202122class Solution { public int maxProfit(int[] prices) { /** 对于任意一天考虑四个变量: fstBuy: 在该天第一次买入股票可获得的最大收益 fstSell: 在该天第一次卖出股票可获得的最大收益 secBuy: 在该天第二次买入股票可获得的最大收益 secSell: 在该天第二次卖出股票可获得的最大收益 分别对四个变量进行相应的更新, 最后secSell就是最大 收益值(secSell &gt;= fstSell) **/ int fstBuy = Integer.MIN_VALUE, fstSell = 0; int secBuy = Integer.MIN_VALUE, secSell = 0; for(int p : prices) { fstBuy = Math.max(fstBuy, -p); fstSell = Math.max(fstSell, fstBuy + p); secBuy = Math.max(secBuy, fstSell - p); secSell = Math.max(secSell, secBuy + p); } return secSell; }} 第124题 123456789101112131415161718192021222324252627282930/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { private int ret = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { /** 对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况: 1. 其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径 2. 左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径 **/ getMax(root); return ret; } private int getMax(TreeNode r) { if(r == null) return 0; int left = Math.max(0, getMax(r.left)); // 如果子树路径和为负则应当置0表示最大路径不包含子树 int right = Math.max(0, getMax(r.right)); ret = Math.max(ret, r.val + left + right); // 判断在该节点包含左右子树的路径和是否大于当前最大路径和 return Math.max(left, right) + r.val; }}","link":"/2019/01/08/blog53/"},{"title":"Leetcode刷题第五十二天","text":"今天自己写出来了一道难题很开心，就是126题，BFS+DFS的结合题目，让人回味无穷啊。 第125题 123456789101112131415161718class Solution { public boolean isPalindrome(String s) { if(s==null)return true; String s1=s.toLowerCase(); String s2=&quot;&quot;; for(int i=0;i&lt;s1.length();i++) { if((s1.charAt(i)&lt;='z'&amp;&amp;s1.charAt(i)&gt;='a')||(s1.charAt(i)&lt;='9'&amp;&amp;s1.charAt(i)&gt;='0')) { s2+=s1.charAt(i); } } for(int i=0;i&lt;s2.length()/2;i++) { if(s2.charAt(i)!=s2.charAt(s2.length()-1-i)) { return false; } } return true; }} 第126题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution { class Word{ String word; int value; public Word(String word,int value) { this.word=word; this.value=value; } } List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) { int idx=1; boolean[] visited=new boolean[wordList.size()]; Map&lt;String,Integer&gt; initMap=new HashMap&lt;&gt;(); Map&lt;String,List&lt;String&gt;&gt; fatherMap=new HashMap&lt;&gt;(); for(int i=0;i&lt;wordList.size();i++) { fatherMap.put(wordList.get(i), new ArrayList&lt;String&gt;()); } LinkedList&lt;Word&gt; queue=new LinkedList&lt;&gt;(); queue.add(new Word(beginWord,idx)); while(!queue.isEmpty()) { Word word1=queue.pop(); if(word1.word.equals(endWord)) { List&lt;String&gt; tmp=new ArrayList&lt;&gt;(); tmp.add(endWord); dfs(tmp,fatherMap,endWord,beginWord); return res; } idx=word1.value+1; for(int i=0;i&lt;wordList.size();i++) { String word2=wordList.get(i); if(compare(word1.word, word2)) { if(visited[i]==false) { queue.add(new Word(word2,idx)); initMap.put(word2, idx); fatherMap.get(word2).add(word1.word); visited[i]=true; }else if(initMap.get(word2)==idx) { fatherMap.get(word2).add(word1.word); } } } } return res; } public void dfs(List&lt;String&gt; list,Map&lt;String,List&lt;String&gt;&gt; map,String endword,String beginword) { if(endword.equals(beginword)) { res.add(new ArrayList&lt;&gt;(list)); return; } for(String s:map.get(endword)) { list.add(0, s); dfs(list,map,s,beginword); list.remove(0); } } public boolean compare(String word1,String word2) { int count=0; for(int i=0;i&lt;word1.length();i++) { if(word1.charAt(i)!=word2.charAt(i)) { count++; if(count&gt;1) { return false; } } } return true; }} 第127题 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { class Word{ String word; int value; public Word(String word,int value) { this.word=word; this.value=value; } } public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) { int idx=1; boolean[] visited=new boolean[wordList.size()]; LinkedList&lt;Word&gt; queue=new LinkedList&lt;&gt;(); queue.add(new Word(beginWord,idx)); while(!queue.isEmpty()) { Word word1=queue.pop(); if(word1.word.equals(endWord))return word1.value; idx=word1.value+1; for(int i=0;i&lt;wordList.size();i++) { String word2=wordList.get(i); if(visited[i]==false&amp;&amp;compare(word1.word, word2)) { queue.add(new Word(word2,idx)); visited[i]=true; } } } return 0; } public boolean compare(String word1,String word2) { int count=0; for(int i=0;i&lt;word1.length();i++) { if(word1.charAt(i)!=word2.charAt(i)) { count++; if(count&gt;1) { return false; } } } return true; }}","link":"/2019/01/09/blog54/"},{"title":"Leetcode刷题第五十三天","text":"最近加了卢老师的实验室，说实话挺开心的，一来就和我讲了很多关于考研和工作的话题，受益匪浅呀，然后最近就喊我做一个数据挖掘的项目，所以又有几天没刷题。 第128题 123456789101112131415161718class Solution { public int longestConsecutive(int[] nums) { int ret = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for(int num : nums) { if(!map.containsKey(num)) { int left = map.getOrDefault(num-1, 0); int right = map.getOrDefault(num+1, 0); int len = left+right+1; ret = len &gt; ret ? len : ret; map.put(num-left, len); map.put(num+right, len); map.put(num, len); } } return ret; }} 第129题 12345678910111213141516171819202122/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { public int sumNumbers(TreeNode root) { if(root==null)return 0; return dfs(root,0); } public int dfs(TreeNode root,int val){ if(root.left==null&amp;&amp;root.right==null)return val+root.val; int leftVal=0,rightVal=0; if(root.left!=null)leftVal=dfs(root.left,10*(val+root.val)); if(root.right!=null)rightVal=dfs(root.right,10*(val+root.val)); return leftVal+rightVal; }} 第130题 1234567891011121314151617181920212223242526272829303132class Solution { public void solve(char[][] board) { if(board==null||board.length==0)return; int row=board.length; int col=board[0].length; for(int i=0;i&lt;row;i++){ dfs(board,i,0); dfs(board,i,col-1); } for(int j=0;j&lt;col;j++){ dfs(board,0,j); dfs(board,row-1,j); } for(int i=0;i&lt;row;i++) { for(int j=0;j&lt;col;j++) { if(board[i][j]=='O')board[i][j]='X'; if(board[i][j]=='-')board[i][j]='O'; } } } public void dfs(char[][] board,int x,int y) { if(x==board.length||x==-1||y==-1||y==board[0].length||board[x][y]!='O') { return; } board[x][y]='-'; dfs(board,x,y+1); dfs(board,x+1,y); dfs(board,x,y-1); dfs(board,x-1,y); }}","link":"/2019/01/15/blog55/"},{"title":"Leetcode刷题第五十四天","text":"第131题 123456789101112131415161718192021222324252627282930class Solution { public List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; partition(String s) { fun(0,s,new ArrayList&lt;String&gt;()); return res; } public void fun(int idx,String s,List&lt;String&gt; list) { if(idx==s.length()) { res.add(new ArrayList&lt;&gt;(list)); return; } for(int i=idx;i&lt;s.length();i++) { if(isHuiwen(s.substring(idx, i+1))) { list.add(s.substring(idx,i+1)); fun(i+1,s,list); list.remove(list.size()-1); } } } public boolean isHuiwen(String s) { for(int i=0;i&lt;s.length()/2;i++) { if(s.charAt(i)!=s.charAt(s.length()-1-i)) { return false; } } return true; }} 第132题 1234567891011121314151617181920212223242526class Solution { public int minCut(String s) { int[] arr=new int[s.length()+1]; if(s==null) return 0; for(int i=-1;i&lt;s.length();i++) { arr[i+1]=i; } for(int i=1;i&lt;=s.length();i++) { for(int j=0;j&lt;i;j++) { if(isHuiwen(s.substring(j, i))) { arr[i]=Math.min(arr[i],arr[j]+1); } } } return arr[s.length()]; } public boolean isHuiwen(String s) { for(int i=0;i&lt;s.length()/2;i++) { if(s.charAt(i)!=s.charAt(s.length()-1-i)) { return false; } } return true; }}","link":"/2019/01/16/blog56/"},{"title":"Leetcode刷题第五十五天","text":"第133题 12345678910111213141516171819202122/*** Definition for undirected graph.* class UndirectedGraphNode {* int label;* List&lt;UndirectedGraphNode&gt; neighbors;* UndirectedGraphNode(int x) { label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); }* };*/public class Solution { Map&lt;Integer,UndirectedGraphNode&gt; map=new HashMap&lt;&gt;(); public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) { if(node==null) return null; UndirectedGraphNode new_node=map.get(node.label); if(new_node!=null)return new_node; new_node=new UndirectedGraphNode(node.label); map.put(new_node.label,new_node); for(UndirectedGraphNode udgnode:node.neighbors) { new_node.neighbors.add(cloneGraph(udgnode)); } return new_node; }} 第134题 12345678910111213141516171819202122232425262728class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n=gas.length; for(int i=0;i&lt;n;i++) { int cha=0; int cur_gas=0; int cur_cost=0; int loc=i; int pos=i; boolean flag=false; do{ cur_gas=cha+gas[loc]; cur_cost=cost[loc]; cha=cur_gas-cur_cost; if(cha&lt;0) { i=pos&gt;=n-1?n-1:pos; flag=true; break; } cur_gas=cha; pos++; loc=(loc+1)%n; }while(loc!=i); if(flag==false)return i; } return -1; }} 第135题 123456789101112131415161718192021222324252627282930class Solution { public int candy(int[] ratings) { int n=ratings.length; int[] dp=new int[n]; dp[0]=1; for(int i=1;i&lt;n;i++) { if(ratings[i]&gt;ratings[i-1]) { dp[i]=dp[i-1]+1; }else if(ratings[i]&lt;ratings[i-1]) { dp[i]=1; if(dp[i-1]==1) { for(int j=i;j&gt;=1;j--) { if(ratings[j-1]&gt;ratings[j]&amp;&amp;dp[j-1]-dp[j]==0) { dp[j-1]+=1; }else { break; } } } }else { dp[i]=1; } } int sum=0; for(int i=0;i&lt;n;i++) { sum+=dp[i]; } return sum; }}","link":"/2019/01/17/blog57/"},{"title":"Leetcode刷题第五十六天","text":"第136题 12345678class Solution { public int singleNumber(int[] nums) { int a=0; for(int num:nums) a=a^num; return a; }} 第137题 12345678910class Solution { public int singleNumber(int[] nums) { int a=0;int b=0; for(int num:nums){ b = ~a &amp; (b ^ num); a = ~b &amp; (a ^ num); } return b; }} 第138题 1234567891011121314151617181920/*** Definition for singly-linked list with a random pointer.* class RandomListNode {* int label;* RandomListNode next, random;* RandomListNode(int x) { this.label = x; }* };*/public class Solution { Map&lt;RandomListNode,RandomListNode&gt; map=new HashMap&lt;&gt;(); public RandomListNode copyRandomList(RandomListNode head) { if(head==null)return null; if(map.containsKey(head))return map.get(head); RandomListNode new_head=new RandomListNode(head.label); map.put(head,new_head); new_head.next=copyRandomList(head.next); new_head.random=copyRandomList(head.random); return new_head; }} 第139题 123456789101112131415class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] dp=new boolean[s.length()+1]; dp[0]=true; for(int i=1;i&lt;=s.length();i++) { for(int j=0;j&lt;i;j++) { if(dp[j]&amp;&amp;wordDict.contains(s.substring(j, i))) { dp[i]=true; break; } } } return dp[s.length()]; }} 第140题 123456789101112131415161718192021222324class Solution { public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) { return dfs(s,wordDict,new HashMap&lt;String,List&lt;String&gt;&gt;()); } public List&lt;String&gt; dfs(String s, List&lt;String&gt; wordDict, Map&lt;String,List&lt;String&gt;&gt; map) { if(map.containsKey(s))return map.get(s); List&lt;String&gt; res=new ArrayList&lt;&gt;(); if(s.length()==0) { res.add(&quot;&quot;); return res; } for(String word:wordDict) { if(s.startsWith(word)) { List&lt;String&gt; subList=dfs(s.substring(word.length()), wordDict, map); for(String sub:subList) { res.add(word+(sub.isEmpty()?&quot;&quot;:&quot; &quot;)+sub); } } } map.put(s, res); return res; }}","link":"/2019/01/18/blog58/"},{"title":"Leetcode刷题第五十七天","text":"第141题 12345678910111213141516171819202122232425/*** Definition for singly-linked list.* class ListNode {* int val;* ListNode next;* ListNode(int x) {* val = x;* next = null;* }* }*/public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head; ListNode fast = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; if(fast == slow){ return true; } } return false; }} 第142题 12345678910111213141516171819202122232425262728293031323334/*** Definition for singly-linked list.* class ListNode {* int val;* ListNode next;* ListNode(int x) {* val = x;* next = null;* }* }*/public class Solution { public ListNode detectCycle(ListNode head) { ListNode fast=head; ListNode slow=head; ListNode p=head; boolean hasCycle=false; while(fast!=null&amp;&amp;fast.next!=null) { fast=fast.next.next; slow=slow.next; if(slow==fast) { hasCycle=true; break; } } if(hasCycle==false)return null; while(p!=null) { if(p==slow)return p; p=p.next; slow=slow.next; } return null; }} 第143题 12345678910111213141516171819202122232425262728293031323334353637/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public void reorderList(ListNode head) { List&lt;ListNode&gt; list=new ArrayList&lt;&gt;(); ListNode cur=head; while(head!=null) { list.add(head); head=head.next; } int n=list.size(); if(n==0)return; ListNode new_head=new ListNode(0); ListNode root=new_head; for(int i=0;i&lt;n/2;i++) { new_head.next=list.get(i); new_head=new_head.next; new_head.next=list.get(n-1-i); new_head=new_head.next; } if(n%2!=0){new_head.next=list.get(n/2);new_head=new_head.next;} new_head.next=null; root=root.next.next; while(root!=null) { cur.next=root; cur=cur.next; root=root.next; } cur.next=null; }} 第144题 12345678910111213141516171819/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorderTraversal(TreeNode root) { if(root==null)return res; res.add(root.val); preorderTraversal(root.left); preorderTraversal(root.right); return res; }} 第145题 12345678910111213141516171819/*** Definition for a binary tree node.* public class TreeNode {* int val;* TreeNode left;* TreeNode right;* TreeNode(int x) { val = x; }* }*/class Solution { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); public List&lt;Integer&gt; postorderTraversal(TreeNode root) { if(root==null)return res; postorderTraversal(root.left); postorderTraversal(root.right); res.add(root.val); return res; }}","link":"/2019/01/21/blog59/"},{"title":"Leetcode刷题第五十八天","text":"第146题 1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache { Map&lt;Integer, Integer&gt; Cache = new HashMap&lt;&gt;(); Map&lt;Integer, Long&gt; timeCache = new HashMap&lt;&gt;(); int capacity; public LRUCache(int capacity) { this.capacity = capacity; } public int get(int key) { if (Cache.containsKey(key)) { timeCache.put(key, System.nanoTime()); return Cache.get(key); } return -1; } public void put(int key, int value) { if (!Cache.containsKey(key)&amp;&amp;Cache.size() == capacity) { long min = Long.MAX_VALUE; Integer target = null; for (Integer i : timeCache.keySet()) { if (min &gt;= timeCache.get(i)) { min = timeCache.get(i); target = i; } } Cache.remove(target); timeCache.remove(target); } Cache.put(key, value); timeCache.put(key, System.nanoTime()); }}/*** Your LRUCache object will be instantiated and called as such:* LRUCache obj = new LRUCache(capacity);* int param_1 = obj.get(key);* obj.put(key,value);*/ 第147题 123456789101112131415161718192021222324/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode insertionSortList(ListNode head) { ListNode p=new ListNode(-1); while(head!=null) { ListNode temp=head.next; ListNode cur=p; while(cur.next!=null&amp;&amp;cur.next.val&lt;=head.val) { cur=cur.next; } head.next=cur.next; cur.next=head; head=temp; } return p.next; }} 第148题 12345678910111213141516171819202122232425262728293031323334353637383940/*** Definition for singly-linked list.* public class ListNode {* int val;* ListNode next;* ListNode(int x) { val = x; }* }*/class Solution { public ListNode sortList(ListNode head) { if(head == null || head.next == null) return head; ListNode slow = head, fast = head, mid = head; while(fast != null &amp;&amp; fast.next != null) { mid = slow; slow = slow.next; fast = fast.next.next; } mid.next = null; ListNode lhead = sortList(head); ListNode rhead = sortList(slow); return merge(lhead, rhead); } public ListNode merge(ListNode h1,ListNode h2) { ListNode res=new ListNode(0); ListNode p=res; while(h1!=null&amp;&amp;h2!=null) { if(h1.val&gt;h2.val) { p.next=h2; h2=h2.next; }else { p.next=h1; h1=h1.next; } p=p.next; } if(h1!=null) p.next=h1; if(h2!=null) p.next=h2; return res.next; }}","link":"/2019/01/23/blog60/"},{"title":"Leetcode刷题第五十九天","text":"rua,今天被生活虐了，开始leetcode第4页题了 第149题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*** Definition for a point.* class Point {* int x;* int y;* Point() { x = 0; y = 0; }* Point(int a, int b) { x = a; y = b; }* }*/import java.math.BigDecimal;import java.math.RoundingMode;class Solution { public int maxPoints(Point[] points) { if(points.length&lt;=2) { return points.length; } int max=0; for(int i=0;i&lt;points.length;i++) { Point A=points[i]; int same=1; Map&lt;BigDecimal,Integer&gt; map=new HashMap&lt;&gt;(); for(int j=i+1;j&lt;points.length;j++) { Point B=points[j]; if(A.y==B.y&amp;&amp;A.x==B.x) { same++; continue; } double up=A.y-B.y; double down=A.x-B.x; BigDecimal gradient=BigDecimal.valueOf(Double.MAX_VALUE); if(down!=0){ gradient=new BigDecimal(up).divide(new BigDecimal(down),16,RoundingMode.CEILING); } if(map.containsKey(gradient)) { map.put(gradient, map.get(gradient)+1); }else { map.put(gradient, 1); } } if(max&lt;same)max=same; for(BigDecimal key:map.keySet()) { if(map.get(key)+same&gt;max) { max=map.get(key)+same; } } } return max; }} 第150题 123456789101112131415161718192021222324class Solution { public int evalRPN(String[] tokens) { Stack&lt;String&gt; stack=new Stack&lt;&gt;(); String srr[]= {&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;}; List&lt;String&gt; list=Arrays.asList(srr); for(String s:tokens) { if(list.contains(s)) { int s1=Integer.parseInt(stack.pop()); int s2=Integer.parseInt(stack.pop()); int res=0; switch(s){ case &quot;+&quot;:res=s1+s2;break; case &quot;-&quot;:res=s2-s1;break; case &quot;*&quot;:res=s1*s2;break; case &quot;/&quot;:res=s2/s1;break; } stack.push(String.valueOf(res)); }else { stack.push(s); } } return Integer.parseInt(stack.pop()); }} 第151题 123456789101112public class Solution { public String reverseWords(String s) { if(s == null || &quot;&quot;.equals(s.trim())) return &quot;&quot;; String[] srr = s.trim().split(&quot;\\\\s{1,}&quot;); s = &quot;&quot;; for (int i = srr.length - 1; i &gt; -1; i--) { s += i == 0 ? srr[i] : srr[i] + &quot; &quot;; } return s; }}","link":"/2019/01/24/blog61/"},{"title":"Leetcode刷题第六十天","text":"第152题 123456789101112class Solution { public int maxProduct(int[] nums) { int max=nums[0],min=nums[0],maxAll=nums[0]; for(int i=1;i&lt;nums.length;i++) { int mx=max,mn=min; max=Math.max(Math.max(nums[i], nums[i]*mx), nums[i]*mn); min=Math.min(Math.min(nums[i], nums[i]*mx), nums[i]*mn); maxAll=Math.max(max, maxAll); } return maxAll; }} 第153题 123456789101112131415161718class Solution { public int findMin(int[] nums) { int min=nums[0]; int left=0,right=nums.length-1; while(left&lt;=right) { int mid=(left+right)/2; if(nums[left]&lt;=nums[mid]) { min=Math.min(nums[left], min); left=mid+1; } if(nums[mid]&lt;=nums[right]) { min=Math.min(nums[mid], min); right=mid-1; } } return min; }} 第154题 1234567891011121314151617class Solution { public int findMin(int[] nums) { int left=0,right=nums.length-1; while(left&lt;right) { int mid=(left+right)/2; if(nums[left]&gt;nums[mid]) { right=mid; } else if(nums[mid]&gt;nums[right]) { left=mid+1; }else{ right-=1; } } return nums[left]; }}","link":"/2019/01/25/blog62/"},{"title":"Leetcode刷题第六十一天","text":"今天出去逛gai！ 第155题 123456789101112131415161718192021222324252627282930class MinStack { Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); public MinStack() { } public void push(int x) { if(stack.isEmpty()) { stack.push(x); stack.push(x); }else { int temp=Math.min(stack.peek(),x); stack.push(x); stack.push(temp); } } public void pop() { stack.pop(); stack.pop(); } public int top() { return stack.get(stack.size()-2); } public int getMin() { return stack.peek(); }} 第160题 12345678910public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode a=headA,b=headB; while(a!=b) { a=a==null?headB:a.next; b=b==null?headA:b.next; } return a; }} 第162题 12345678910111213141516class Solution { public int findPeakElement(int[] nums) { return fun(0,nums.length-1,nums); } public int fun(int left,int right,int[] nums) { if(left&lt;right) { int mid=(left+right)/2; int idx1=fun(left,mid,nums); int idx2=fun(mid+1,right,nums); if(nums[idx2]&gt;nums[idx1])return idx2; else return idx1; } return left; }} 第164题 12345678910111213141516171819202122232425262728293031323334class Solution { public int maximumGap(int[] nums) { if(nums.length&lt;2)return 0; int min=Integer.MAX_VALUE,max=Integer.MIN_VALUE; for(int num:nums) { min=Math.min(num,min); max=Math.max(num,max); } if(min==max) return 0; int bucketlen=(int) Math.ceil((double)(max-min)/(nums.length-1)); int bucketnum=(max-min)/bucketlen; int[] maxBucket=new int[bucketnum+1]; int[] minBucket=new int[bucketnum+1]; Arrays.fill(maxBucket, Integer.MIN_VALUE); Arrays.fill(minBucket, Integer.MAX_VALUE); for(int num:nums) { int temp=(num-min)/bucketlen; maxBucket[temp]=Math.max(maxBucket[temp], num); minBucket[temp]=Math.min(minBucket[temp], num); } int gap=0; int maxVal=maxBucket[0]; for(int i=1;i&lt;minBucket.length;i++) { if(maxBucket[i]==Integer.MIN_VALUE||minBucket[i]==Integer.MAX_VALUE) { continue; } if(gap&lt;minBucket[i]-maxVal) { gap=minBucket[i]-maxVal; } maxVal=maxBucket[i]; } return gap; }}","link":"/2019/01/26/blog63/"},{"title":"Leetcode刷题第六十二天","text":"Weekly Contest 121 第984题1234567891011121314151617181920212223242526class Solution { public String strWithout3a3b(int A, int B) { char[] crr=new char[A+B]; for(int i=0;i&lt;crr.length;i++) { if(i&gt;=2&amp;&amp;crr[i-1]==crr[i-2]) { if(crr[i-1]=='a') { crr[i]='b'; B--; }else { crr[i]='a'; A--; } }else { if(A&gt;B) { crr[i]='a'; A--; }else { crr[i]='b'; B--; } } } return new String(crr); }} 第981题1234567891011121314151617181920212223class TimeMap { Map&lt;String,TreeMap&lt;Integer,String&gt;&gt; map=new HashMap&lt;&gt;(); public TimeMap() { } public void set(String key, String value, int timestamp) { if(!map.containsKey(key)) { TreeMap&lt;Integer,String&gt; temp=new TreeMap&lt;&gt;(); map.put(key, temp); } Map&lt;Integer,String&gt; temp=map.get(key); temp.put(timestamp, value); } public String get(String key, int timestamp) { TreeMap&lt;Integer,String&gt; temp=map.get(key); if(temp==null)return &quot;&quot;; Map.Entry&lt;Integer, String&gt; entry=temp.floorEntry(timestamp); if(entry==null)return &quot;&quot;; return entry.getValue(); }} 第983题123456789101112131415161718class Solution { public int mincostTickets(int[] days, int[] costs) { int[] dp=new int[days.length+1]; dp[0]=0; for(int i=1;i&lt;dp.length;i++) { dp[i]=dp[i-1]+costs[0]; for(int j=i-1;j&gt;=0;j--) { if(days[i-1]-days[j]+1&lt;=7) { dp[i]=Math.min(dp[i], dp[j]+costs[1]); } if(days[i-1]-days[j]+1&lt;=30) { dp[i]=Math.min(dp[i], dp[j]+costs[2]); } } } return dp[dp.length-1]; }} 第982题1234567891011121314151617class Solution { int res=0; public int countTriplets(int[] A) { fun(0,A,65535); return res; } public void fun(int idx,int[] A,int value) { if(idx==3) { if(value==0)res++; return; } for(int i=0;i&lt;A.length;i++) { fun(idx+1,A,value&amp;A[i]); } }}","link":"/2019/01/27/blog64/"},{"title":"Leetcode刷题第六十三天","text":"第165题 12345678910111213141516171819class Solution { public int compareVersion(String version1, String version2) { String srr1[]=version1.split(&quot;\\\\.&quot;); String srr2[]=version2.split(&quot;\\\\.&quot;); int i=0,j=0; int a,b; while(i&lt;srr1.length||j&lt;srr2.length) { if(i&lt;srr1.length)a=Integer.parseInt(srr1[i]); else a=0; if(j&lt;srr2.length)b=Integer.parseInt(srr2[j]); else b=0; if(a&gt;b)return 1; if(b&gt;a)return -1; i++; j++; } return 0; }} 第166题 123456789101112131415161718192021222324252627282930313233343536373839class Solution { public String fractionToDecimal(int numerator, int denominator) { if(numerator==0)return &quot;0&quot;; if(denominator==0)return &quot;NaN&quot;; List&lt;Long&gt; reminder=new ArrayList&lt;&gt;(); List&lt;Long&gt; list=new ArrayList&lt;&gt;(); long a=(long)numerator; long b=(long)denominator; String s=(numerator&gt;0&amp;&amp;denominator&gt;0)||(numerator&lt;0&amp;&amp;denominator&lt;0)?&quot;&quot;:&quot;-&quot;; a=Math.abs(a); b=Math.abs(b); long res=a/b; long remain=a%b; if(remain!=0)s+=res+&quot;.&quot;;else s+=res; while(remain!=0) { remain*=10; if(reminder.contains(remain)) { for(int i=0;i&lt;reminder.indexOf(remain);i++) { s+=Math.abs(list.get(i)); } s+=&quot;(&quot;; for(int i=reminder.indexOf(remain);i&lt;reminder.size();i++) { s+=Math.abs(list.get(i)); } s+=&quot;)&quot;; return s; }else { reminder.add(remain); } res=remain/b; remain=remain%b; list.add(res); } for(Long i:list) { s+=Math.abs(i); } return s; }} 第167题 1234567891011class Solution { public int[] twoSum(int[] numbers, int target) { int i=0,j=numbers.length-1; while(i&lt;j) { if(numbers[i]+numbers[j]==target)return new int[]{i+1,j+1}; else if(numbers[i]+numbers[j]&gt;target)j--; else i++; } return null; }}","link":"/2019/01/29/blog65/"},{"title":"Leetcode刷题第六十四天","text":"第168题 1234567891011121314class Solution { public String convertToTitle(int n) { char[] alphbet= {'Z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}; return fun(alphbet,n); } public String fun(char[] alphbet,int rs) { if(rs&lt;27) { return alphbet[rs]+&quot;&quot;; } String s=fun(alphbet,(rs-1)/26)+alphbet[rs%26]; return s; }} 第169题 1234567891011class Solution { public int majorityElement(int[] nums) { int count=0,res=0; for(int num:nums) { if(count==0)res=num; if(num==res)count++; if(num!=res)count--; } return res; }} 第171题 12345678910111213class Solution { public int titleToNumber(String s) { int n=s.length()-1; int res=0; while(n&gt;=0) { char tmp=s.charAt(n); int val=(tmp-'A'+1)*(int)Math.pow(26,(s.length()-n-1)); res+=val; n--; } return res; }} 第172题 12345678910class Solution { public int trailingZeroes(int n) { int total=0; while(n&gt;1) { n/=5; total+=n; } return total; }} 第173题 12345678910111213141516171819202122232425262728class BSTIterator { Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;TreeNode&gt; list=new ArrayList&lt;&gt;(); int idx=0; public BSTIterator(TreeNode root) { TreeNode cur=root; while(cur!=null || !stack.isEmpty()) { while(cur!=null) { stack.push(cur); cur=cur.left; } if(!stack.isEmpty()) { TreeNode tmp=stack.pop(); list.add(tmp); cur=tmp.right; } } } public int next() { return list.get(idx++).val; } public boolean hasNext() { return !(idx==list.size()); }} 第174题 1234567891011121314151617181920212223class Solution { public int calculateMinimumHP(int[][] dungeon) { int row = dungeon.length; int col = dungeon[0].length; int[][] dp = new int[row+1][col + 1]; for(int i=0;i&lt;=row;i++)dp[i][col]=Integer.MAX_VALUE; for(int i=0;i&lt;=col;i++)dp[row][i]=Integer.MAX_VALUE; for(int i=row-1;i&gt;=0;i--) { for(int j=col-1;j&gt;=0;j--) { if(i==row-1&amp;&amp;j==col-1) { if(dungeon[i][j]&gt;0)dp[i][j]=1; else dp[i][j]=-dungeon[i][j]+1; continue; } int val=Math.min(dp[i+1][j], dp[i][j+1]); if(dungeon[i][j]&gt;val)dp[i][j]=1; else dp[i][j]=val-dungeon[i][j]; dp[i][j]=dp[i][j]==0?1:dp[i][j]; } } return dp[0][0]; }}","link":"/2019/01/30/blog66/"},{"title":"Leetcode刷题第六十五天","text":"第179题 1234567891011121314151617181920212223class Solution { public String largestNumber(int[] nums) { String[] srr=new String[nums.length]; for(int i=0;i&lt;nums.length;i++) { srr[i]=String.valueOf(nums[i]); } Arrays.sort(srr,new Comparator&lt;String&gt;() { @Override public int compare(String o1, String o2) { long val1=Long.parseLong(o1+o2); long val2=Long.parseLong(o2+o1); if(val1&gt;val2)return -1; else return 1; } }); if(srr[0].equals(&quot;0&quot;))return &quot;0&quot;; String res=&quot;&quot;; for(int i=0;i&lt;srr.length;i++) { res+=srr[i]; } return res; }} 第187题 123456789101112class Solution { public List&lt;String&gt; findRepeatedDnaSequences(String s) { Set&lt;String&gt; res=new HashSet&lt;&gt;(); Set&lt;String&gt; temp=new HashSet&lt;&gt;(); for(int i=0;i&lt;=s.length()-10;i++) { String ss=s.substring(i, i+10); if(temp.contains(ss))res.add(ss); else temp.add(ss); } return new ArrayList&lt;&gt;(res); }} 第188题 12345678910111213141516171819202122232425class Solution { public int maxProfit(int k, int[] prices) { if(k==0)return 0; if (prices.length / 2 &lt; k) { int sum = 0; for (int i = 1; i &lt; prices.length; i++) { if (prices[i] &gt; prices[i - 1]) sum += prices[i] - prices[i - 1]; } return sum; } int[] buyarr=new int[k]; int[] sellarr=new int[k]; Arrays.fill(buyarr,Integer.MIN_VALUE); for(int price:prices) { buyarr[0]=Math.max(buyarr[0], -price); sellarr[0]=Math.max(sellarr[0],buyarr[0]+price ); for(int i=1;i&lt;k;i++) { buyarr[i]=Math.max(buyarr[i], sellarr[i-1]-price); sellarr[i]=Math.max(sellarr[i],buyarr[i]+price ); } } return sellarr[k-1]; }}","link":"/2019/01/31/blog67/"},{"title":"Leetcode刷题第六十六天","text":"第189题 12345678910111213class Solution { public void rotate(int[] nums, int k) { int n = nums.length; k %= n; while(k--&gt;0) { int last=nums[nums.length-1]; for(int i=nums.length-1;i&gt;0;i--) { nums[i]=nums[i-1]; } nums[0]=last; } }} 第190题 12345public class Solution { public int reverseBits(int n) { return Integer.reverse(n); }} 第191题 12345public class Solution { public int hammingWeight(int n) { return Integer.bitCount(n); }} 第198题 123456789101112class Solution { public int rob(int[] nums) { if(nums.length==0)return 0; int[] dp=new int[nums.length+1]; dp[0]=0; dp[1]=nums[0]; for(int i=2;i&lt;=nums.length;i++) { dp[i]=Math.max(dp[i-1], dp[i-2]+nums[i-1]); } return dp[nums.length]; }} 第199题 123456789101112131415161718class Solution { public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(root==null)return res; Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()) { int length=queue.size(); res.add(queue.peek().val); for(int i=0;i&lt;length;i++) { TreeNode cur=queue.poll(); if(cur.right!=null)queue.add(cur.right); if(cur.left!=null)queue.add(cur.left); } } return res; }} 第200题 12345678910111213141516171819202122232425262728class Solution { char grid[][]; public int numIslands(char[][] grid) { int res=0; this.grid=grid; for(int i=0;i&lt;grid.length;i++) { for(int j=0;j&lt;grid[0].length;j++) { if(grid[i][j]=='1') { dfs(i,j); res++; } } } return res; } public void dfs(int i,int j) { if(i&lt;0||j&lt;0||i&gt;=grid.length||j&gt;=grid[0].length) { return; } if(grid[i][j]=='0')return; grid[i][j]='0'; dfs(i+1,j); dfs(i,j+1); dfs(i-1,j); dfs(i,j-1); }}","link":"/2019/02/01/blog68/"},{"title":"Leetcode刷题第六十七天","text":"第201题 1234567891011class Solution { public int rangeBitwiseAnd(int m, int n) { int count=0; while(m!=0&amp;&amp;m!=n) { m=m&gt;&gt;1; n=n&gt;&gt;1; count++; } return m&lt;&lt;count; }} 第202题 123456789101112131415161718class Solution { public boolean isHappy(int n) { if(n==1)return true; Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); set.add(n); while(n!=1) { String s=String.valueOf(n); int temp=0; for(int i=0;i&lt;s.length();i++) { temp+=Math.pow(Integer.parseInt(s.charAt(i)+&quot;&quot;),2); } if(set.contains(temp))return false; set.add(temp); n=temp; } return true; }} 第203题 123456789101112131415class Solution { public ListNode removeElements(ListNode head, int val) { ListNode new_head=new ListNode(0); ListNode p=new_head; while(head!=null) { if(head.val!=val) { p.next=head; p=p.next; } head=head.next; } p.next=null; return new_head.next; }} 第204题 12345678910111213141516class Solution { public int countPrimes(int n) { boolean[] isNotPrime=new boolean[n]; for(int i=2;i*i&lt;n;i++) { if(isNotPrime[i])continue; for(int j=i*i;j&lt;n;j+=i) { isNotPrime[j]=true; } } int count=0; for(int i=2;i&lt;isNotPrime.length;i++) { if(!isNotPrime[i])count++; } return count; }}","link":"/2019/02/02/blog69/"},{"title":"Leetcode刷题第六十八天","text":"Weekly Contest 122 1234567891011121314class Solution { public int[] sumEvenAfterQueries(int[] A, int[][] queries) { int[] ans=new int[queries.length]; for(int i=0;i&lt;queries.length;i++) { A[queries[i][1]]+=queries[i][0]; int temp=0; for(int j=0;j&lt;A.length;j++) { if(A[j]%2==0)temp+=A[j]; } ans[i]=temp; } return ans; }} 1234567891011121314151617181920212223242526272829303132class Solution { public Interval[] intervalIntersection(Interval[] A, Interval[] B) { List&lt;Interval&gt; list = new ArrayList&lt;&gt;(); if(A.length&gt;B.length) { for(int i=0;i&lt;A.length;i++) { Interval a=A[i]; for(int j=0;j&lt;B.length;j++) { Interval b=B[j]; if ((a.end &gt;= b.start &amp;&amp; a.start &lt;= b.end) || (b.end &gt;= a.start &amp;&amp; b.start &lt;= a.end)) { int start = Math.max(a.start, b.start); int end = Math.min(a.end, b.end); list.add(new Interval(start, end)); } } } }else { for(int i=0;i&lt;B.length;i++) { Interval b=B[i]; for(int j=0;j&lt;A.length;j++) { Interval a=A[j]; if ((a.end &gt;= b.start &amp;&amp; a.start &lt;= b.end) || (b.end &gt;= a.start &amp;&amp; b.start &lt;= a.end)) { int start = Math.max(a.start, b.start); int end = Math.min(a.end, b.end); list.add(new Interval(start, end)); } } } } Interval[] ans = new Interval[list.size()]; return list.toArray(ans); }} 12345678910111213141516class Solution { String res=&quot;~&quot;; public String smallestFromLeaf(TreeNode root) { dfs(root,&quot;&quot;); return res; } public void dfs(TreeNode root,String s) { if(root==null)return; s=(char)('a'+root.val)+s; if(root.left==null&amp;&amp;root.right==null) { if(s.compareTo(res)&lt;0)res=s; } dfs(root.left,s); dfs(root.right,s); }}","link":"/2019/02/03/blog70/"},{"title":"SPFA——BFS的一种扩展","text":"一句话总结本篇题解内容：BFS 中每个点只入列一次，但有时，我们可能需要 bfs 中允许一个点入列多次才能解决问题，这种方法就是 SPFA。 SPFA 这种算法，如果你百度的话，你会发现大多是说他用于求最短路的，事实上，更宽泛的来理解，所有“可能要后悔”的 BFS，都可以用类似 SPFA 的思路来解决。 先说说经典的最短路问题，希望大家能借此理解为何说 SPFA 是可以“后悔”的。 考虑这样一张图，1 号点是起点，边上的数字代表这条边的长度，你想求出 1 到 10 号点的最短路。 下面，说说为何朴素的 bfs 不行。 按照 bfs 的流程，初始 1 号点入列，然后 1 号点周围的 2 号和 3 号入列。此时，2 距 1 最短路更新为 4,3 距 1 最短路更新为 1。 于是，问题来了，我们看到，实际上 1 到 2 的最短路是 1-&gt;3-&gt;4-&gt;2，其长度为 3。 但按照朴素的 BFS 来做，由于已经有 vis[2]=1 了，所以由 4 号点访问周围点时，2 号点就不会再入列了，这样，我们就会求出错误的最短路。 那怎么办呢？一个很显然的办法，就是————————那我就再把 2 入列呗！ 所以，SPFA 其实就是很简单的一件事儿：检测到某点距离变化，就把某点入列。 并且如前所述，这样的 SPFA 其实就不需要 vis 数组了，因为只要距离更新，点就要入列。 但下面代码中还是有 vis 数组，其实他的含义是：某个点当前正在队列里，vis 值为 1，当前点不在队列里，vis 值为 0。需要注意，虽然名字都叫 vis，但这里的 vis 数组和朴素 BFS 中的 vis 数组很不一样。这里 vis 数组只是避免同一个点已经在队列里的情况下被加入队列多次而用的（再次强调，SPFA 是允许一个点多次入列的，只不过正在队列里的，确实没必要再入列了）。 那么具体看这道题，dis[i][j]表示到达第 i 行第 j 列的点所需要的最小花费，直接的状态转移看上去并不好想。 怎么办？ 不好想就不想了呗！ 只要某个点 dis 变得更小了，我们按照 SPFA 的思想，就二话不说给他入列，让他再更新周围点的 dis，这样总是对的了吧。 所以说白了，SPFA，听上去高大上，其实是贼暴力的一种方法，只要检测到某点 dis 值改变，就在重新由这点开始 bfs，仅此而已。 下面是代码： 1234567891011121314151617181920212223242526272829303132333435363738#define INF 10005int dis[105][105];bool inQue[105][105];int dx[]={0,0,0,1,-1};int dy[]={0,1,-1,0,0};class Solution {public: int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid) { int n=grid.size();int m=grid[0].size(); memset(dis,INF,sizeof(dis)); memset(inQue,false,sizeof(inQue)); queue&lt;pair&lt;int,int&gt;&gt; q; q.push(make_pair(0,0)); inQue[0][0]=true; dis[0][0]=0; while(!q.empty()){ auto now=q.front();q.pop(); int x=now.first;int y=now.second; inQue[x][y]=false; for(int k=1;k&lt;5;k++){ if(x+dx[k]&lt;0||x+dx[k]&gt;=n||y+dy[k]&lt;0||y+dy[k]&gt;=m)continue; int val= k==grid[x][y]?dis[x][y]:dis[x][y]+1; if(dis[x+dx[k]][y+dy[k]]&gt;val){ dis[x+dx[k]][y+dy[k]]=val; if(!inQue[x+dx[k]][y+dy[k]]){ q.push(make_pair(x+dx[k],y+dy[k])); inQue[x+dx[k]][y+dy[k]]=true; } } } } return dis[n-1][m-1]; }};","link":"/2020/09/03/SPFA%E2%80%94%E2%80%94BFS%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%A9%E5%B1%95/"}],"tags":[{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"tech","slug":"tech","link":"/tags/tech/"}],"categories":[]}